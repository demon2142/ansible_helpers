#!/usr/bin/perl

###SCRIPT for generate ifcfg-files, resolv.conf for each inventory host and dynamic playbooks for ifcfg and resolv.conf

use strict;
use warnings;
use Cwd;
use Data::Dumper;

our ($self_dir_g,$script_name_g)=Cwd::abs_path($0)=~/(.*[\/\\])(\S+)$/;

###ARGV
our $gen_playbooks_next_g=0;
our $gen_playbooks_next_with_rollback_g=0;
if ( defined($ARGV[0]) && $ARGV[0]=~/^gen_dyn_playbooks$/ ) {
    $gen_playbooks_next_g=1;
}
elsif ( defined($ARGV[0]) && $ARGV[0]=~/^gen_dyn_playbooks_with_rollback$/ ) {
    $gen_playbooks_next_g=1;
    $gen_playbooks_next_with_rollback_g=1;
}
###ARGV

###CFG file
our $conf_file_g=$self_dir_g.'config';
our $conf_file_del_not_configured_g=$self_dir_g.'/01_configs/config_del_not_configured_ifcfg';
our $conf_temp_apply_g=$self_dir_g.'/01_configs/config_temporary_apply_ifcfg';
our $conf_dns_g=$self_dir_g.'/01_configs/dns_settings'; #for configure resolv.conf
###CFG file

############STATIC VARS. Change dir paths if you want just use this script without ansible helper
our $dyn_ifcfg_common_dir_g=$self_dir_g.'playbooks/dyn_ifcfg_playbooks/dyn_ifcfg'; # dir for save generated ifcfg-files
our $dyn_resolv_common_dir_g=$self_dir_g.'playbooks/dyn_ifcfg_playbooks/dyn_resolv_conf'; # dir for save generated resolv-conf-files
our $dyn_ifcfg_playbooks_dir_g=$self_dir_g.'playbooks/dyn_ifcfg_playbooks'; # dir for save generated dynamic playbooks. Playbooks will be created if changes needed
our $ifcfg_tmplt_dir_g=$self_dir_g.'playbooks/ifcfg_tmplt'; # dir with ifcfg templates
our $ifcfg_backup_from_remote_dir_g=$self_dir_g.'playbooks/ifcfg_backup_from_remote/now'; # dir contains actual ifcfg-files downloaded from remote hosts with help of playbook 'ifcfg_backup_playbook.yml' before run this script
our $ifcfg_backup_from_remote_nd_file_g=$self_dir_g.'playbooks/ifcfg_backup_from_remote/network_data/inv_hosts_interfaces_info.txt'; # dir contains actual network_data (eth, hwaddr) downloaded from remote hosts with help of playbook 'ifcfg_backup_playbook.yml' before run this script
our $remote_dir_for_absible_helper_g='~/ansible_helpers/conf_int_ipv4_via_network_scripts'; # dir for creating/manipulate files at remote side
############STATIC VARS

############VARS
our ($exec_res_g,$exec_status_g)=(undef,'OK');
######
our %cfg0_hash_g=();
#$cfg0_hash_g{inv_host-conf_id}{conf_type}{'main'}{'_inv_host_'}=inv_host;
#$cfg0_hash_g{inv_host-conf_id}{conf_type}{'main'}{'_conf_id_'}=conf_id;
#$cfg0_hash_g{inv_host-conf_id}{conf_type}{'main'}{'_vlan_id_'}=vlan_id;
#$cfg0_hash_g{inv_host-conf_id}{conf_type}{'main'}{'_bond_name_'}=bond_name;
#$cfg0_hash_g{inv_host-conf_id}{conf_type}{'main'}{'_bridge_name_'}=bridge_name;
#$cfg0_hash_g{inv_host-conf_id}{conf_type}{'main'}{'_defroute_'}=defroute;
#$cfg0_hash_g{inv_host-conf_id}{conf_type}{'main'}{'_ipaddr_'}=ipaddr/dhcp;
#$cfg0_hash_g{inv_host-conf_id}{conf_type}{'main'}{'_gw_'}=gw/dhcp;
#$cfg0_hash_g{inv_host-conf_id}{conf_type}{'main'}{'_netmask_'}=gw/dhcp;
#$cfg0_hash_g{inv_host-conf_id}{conf_type}{'main'}{'_bond_opts_'}=bond_opts_string_for_ifcfg;
#$cfg0_hash_g{inv_host-conf_id}{conf_type}{'int_list'}=[array of interfaces];
#$cfg0_hash_g{inv_host-conf_id}{conf_type}{'hwaddr_list'}=[array of hwaddr];
######

our %conf_type_sub_refs_g=(
    #common (novlan)
    'just_interface'=>\&just_interface_gen_ifcfg,
    'virt_bridge'=>\&virt_bridge_gen_ifcfg,
    'just_bridge'=>\&just_bridge_gen_ifcfg,
    'just_bond'=>\&just_bond_gen_ifcfg,
    'bond-bridge'=>\&bond_bridge_gen_ifcfg,
    #
    #vlan
    'interface-vlan'=>\&interface_vlan_gen_ifcfg,
    'bridge-vlan'=>\&bridge_vlan_gen_ifcfg,
    'bond-vlan'=>\&bond_vlan_gen_ifcfg,
    'bond-bridge-vlan'=>\&bond_bridge_vlan_gen_ifcfg,
);

our %inv_hosts_hash0_g=(); #key=inv_host, value=1
our %inv_hosts_hash1_g=(); #key0=inv_host, key1=now/fin (generated by this script)/for_upd/for_del, key2=ifcfg_name
our %inv_hosts_ifcfg_del_not_configured_g=(); #for config 'config_del_not_configured_ifcfg'. Key=inv_host
our %inv_hosts_dns_g=(); #key=inv_host/common, value=[array of nameservers]
our %inv_hosts_tmp_apply_cfg_g=(); #key=inv_host/common, value=rollback_ifcfg_timeout
###
our %inv_hosts_network_data_g=();
#read 'ip_link_noqueue' first
#v1) key0='hwaddr_all', key1=hwaddr, value=inv_host
#v2) key0='inv_host', key1=inv_host, key2=interface_name, key3=hwaddr
############VARS

######MAIN SEQ
while ( 1 ) { # ONE RUN CYCLE begin
    ###READ network data for checks
    $exec_res_g=&read_network_data_for_checks($ifcfg_backup_from_remote_nd_file_g,\%inv_hosts_network_data_g);
    #$file_l,$res_href_l
    if ( $exec_res_g=~/^fail/ ) {
	$exec_status_g='FAIL';
	print "$exec_res_g\n";
	last;
    }
    ###READ network data for checks
    
    ###READ config
    $exec_res_g=&read_main_config($conf_file_g,\%inv_hosts_network_data_g,\%cfg0_hash_g);
    #$file_l,$inv_hosts_network_data_href_l,$res_href_l
    if ( $exec_res_g=~/^fail/ ) {
	$exec_status_g='FAIL';
	print "$exec_res_g\n";
	last;
    }
    ###READ config
    
    ###REcreate ifcfg_tmplt
    $exec_res_g=&recreate_ifcfg_tmplt_based_on_cfg0_hash($dyn_ifcfg_common_dir_g,$ifcfg_tmplt_dir_g,\%cfg0_hash_g,\%conf_type_sub_refs_g,\%inv_hosts_hash0_g);
    #$dyn_ifcfg_common_dir_l,$ifcfg_tmplt_dir_l,$cfg0_hash_href_l,$conf_type_sub_refs_href_l,$res_inv_hosts_hash0_href_l
    if ( $exec_res_g=~/^fail/ ) {
	$exec_status_g='FAIL';
	print "$exec_res_g\n";
	last;
    }
    ###REcreate ifcfg_tmplt
    
    if ( $gen_playbooks_next_g==1 ) { # if need to generate dynamic playbooks for ifcfg upd/del and resolv-conf-files at final    
	###READ conf file 'dns_settings' and generate resolv-conf-files
	    #$dyn_resolv_common_dir_g=$self_dir_g.'playbooks/dyn_ifcfg_playbooks/dyn_resolv_conf' -> files: 'inv_host_resolv' or 'common_resolv'
	    #%inv_hosts_dns_g=(); #key=inv_host/common, value=[array of nameservers]
	$exec_res_g=&generate_resolv_conf_files($conf_dns_g,$dyn_resolv_common_dir_g,\%inv_hosts_dns_g);
	#$conf_dns_l,$dyn_resolv_common_dir_l,$res_inv_hosts_dns_href_l
	if ( $exec_res_g=~/^fail/ ) {
	    $exec_status_g='FAIL';
	    print "$exec_res_g\n";
	    last;
	}
	###READ conf file 'dns_settings' and generate resolv-conf-files
	
	###READ conf file 'config_del_not_configured_ifcfg'
	#%inv_hosts_ifcfg_del_not_configured_g=(); #for config 'config_del_not_configured_ifcfg'. Key=inv_host
	$exec_res_g=&read_config_del_not_configured_ifcfg($conf_file_del_not_configured_g,\%inv_hosts_ifcfg_del_not_configured_g);
	#$file_l,$res_href_l
	if ( $exec_res_g=~/^fail/ ) {
    	    $exec_status_g='FAIL';
    	    print "$exec_res_g\n";
	    last;
	}
	###READ conf file 'config_del_not_configured_ifcfg'
	
	###READ conf file 'config_temporary_apply_ifcfg'
	    #%inv_hosts_tmp_apply_cfg_g=(); #key=inv_host/common, value=rollback_ifcfg_timeout
	$exec_res_g=&read_config_temporary_apply_ifcfg($conf_temp_apply_g,\%inv_hosts_tmp_apply_cfg_g);
	#$file_l,$res_href_l
	if ( $exec_res_g=~/^fail/ ) {
    	    $exec_status_g='FAIL';
    	    print "$exec_res_g\n";
	    last;
	}
	###READ conf file 'config_temporary_apply_ifcfg'
	
	###FILL %inv_hosts_hash1_g
	    #$dyn_ifcfg_common_dir/$inv_host = get inv_hosts + fin = get list of interfaces
	    #$ifcfg_backup_from_remote_dir/inv_host = get actual ifcfg-files
	    #%inv_hosts_hash0_g=(); #key=inv_host, value=1
	$exec_res_g=&fill_inv_hosts_hash1_with_fin_n_now_dirs($dyn_ifcfg_common_dir_g,$ifcfg_backup_from_remote_dir_g,\%inv_hosts_hash0_g,\%inv_hosts_hash1_g);
	#$dyn_ifcfg_common_dir_l,$ifcfg_backup_from_remote_dir_l,$inv_hosts_hash0_href_l,$res_href_l
	if ( $exec_res_g=~/^fail/ ) {
    	    $exec_status_g='FAIL';
    	    print "$exec_res_g\n";
	    last;
	}
	######
	
	######MODIFY %inv_hosts_hash1_g
	    #%inv_hosts_hash1_g=(); #key0=inv_host, key1=now/fin (generated by this script)/for_upd/for_del, key2=ifcfg_name
	    #$dyn_ifcfg_common_dir/$inv_host = get inv_hosts + fin = get list of interfaces
	    #$ifcfg_backup_from_remote_dir/inv_host = get actual ifcfg-files
	    #%inv_hosts_hash0_g=(); #key=inv_host, value=1
	$exec_res_g=&modify_inv_hosts_hash1($dyn_ifcfg_common_dir_g,$ifcfg_backup_from_remote_dir_g,$ifcfg_backup_from_remote_nd_file_g,\%inv_hosts_ifcfg_del_not_configured_g,\%inv_hosts_hash1_g);
	#$dyn_ifcfg_common_dir_l,$ifcfg_backup_from_remote_dir_l,$ifcfg_backup_from_remote_nd_file_l,$inv_hosts_ifcfg_del_not_configured_href_l,$res_href_l
	if ( $exec_res_g=~/^fail/ ) {
    	    $exec_status_g='FAIL';
    	    print "$exec_res_g\n";
	    last;
	}
	######
	
	######GENERATE dynamic playbooks
	$exec_res_g=&generate_dynamic_playbooks($dyn_ifcfg_playbooks_dir_g,$remote_dir_for_absible_helper_g,$gen_playbooks_next_with_rollback_g,\%inv_hosts_tmp_apply_cfg_g,\%inv_hosts_dns_g,\%inv_hosts_hash1_g);
	#$dyn_ifcfg_playbooks_dir_l,$remote_dir_for_absible_helper_l,$gen_playbooks_next_with_rollback_l,$inv_hosts_tmp_apply_cfg_href_l,$inv_hosts_dns_href_l,$inv_hosts_hash1_href_l
	if ( $exec_res_g=~/^fail/ ) {
    	    $exec_status_g='FAIL';
    	    print "$exec_res_g\n";
	    last;
	}
	######
    }
    
    last;
}# ONE RUN CYCLE end

system("echo $exec_status_g > GEN_DYN_IFCFG_STATUS");
if ( $exec_status_g!~/^OK$/ ) {
    print "EXEC_STATUS not OK. Exit!\n\n";
    exit;
}
######MAIN SEQ

######SUBROUTINES
##general subs
sub read_network_data_for_checks {
    my ($file_l,$res_href_l)=@_;
    #file_l=$ifcfg_backup_from_remote_nd_file_g
    #res_href_l=hash-ref for %inv_hosts_network_data_g
    my $proc_name_l=(caller(0))[3];
    
    my ($line_l,$value_cnt_l)=(undef,0);
    my @arr0_l=undef;
    
    if ( length($file_l)<1 or ! -e($file_l) ) { return "fail [$proc_name_l]. File='$file_l' is not exists"; }

    open(NDATA,'<',$file_l);
    while ( <NDATA> ) {
	$line_l=$_;
	$line_l=~s/\n$|\r$|\n\r$|\r\n$//g;
	while ($line_l=~/\t/) { $line_l=~s/\t/ /g; }
	$line_l=~s/\s+/ /g;
	$line_l=~s/^ //g;
	$line_l=~s/ $//g;
	if ( length($line_l)>0 && $line_l!~/^\#/ ) {
	    #INV_HOST-0       #INT_NAME-1       #HWADDR-2
	    @arr0_l=split(' ',$line_l);
	    ${$res_href_l}{'hwaddr_all'}{$arr0_l[2]}=$arr0_l[0];
	    ${$res_href_l}{'inv_host'}{$arr0_l[0]}{$arr0_l[1]}{$arr0_l[2]}=1;
	    $value_cnt_l++; 
	}
    }
    close(NDATA);

    $line_l=undef;

    if ( $value_cnt_l<1 ) { return "fail [$proc_name_l]. No needed data at file='$file_l'"; }

    return 'OK';
}

sub read_main_config {
    my ($file_l,$inv_hosts_network_data_href_l,$res_href_l)=@_;
    #file_l=config,$res_href_l=hash rer for %cfg0_hash_g
    #inv_hosts_network_data_href_l=hash ref for %inv_hosts_network_data_g
    my $proc_name_l=(caller(0))[3];
    
    my ($line_l,$arr_el0_l,$arr_i0_l)=(undef,undef,undef);
    my $return_str_l='OK';
    
    my @arr0_l=();
    my @int_list_arr_l=();
    my @hwaddr_list_arr_l=();
    my @ipaddr_opts_arr_l=();

    my $bond_opts_str_def_l='mode=4 xmit_hash_policy=2 lacp_rate=1 miimon=100';
    my $bond_opts_str_l=$bond_opts_str_def_l;

    my %cfg0_uniq_check_l=();
    #Checks (uniq) for novlan interfaces at current inv_host.
    #$cfg0_uniq_check{inv_host}{'common'}{interface_name}=conf_id; #if interface_name ne 'no' and vlan_id eq 'no'.
    #$cfg0_uniq_check{inv_host}{'common'}{hwaddr}=conf_id; if vlan_id eq 'no'.
    #$cfg0_uniq_check{inv_host}{'common'}{bond_name}=conf_id; #if bond_name ne 'no' and vlan_id eq 'no'.
    #$cfg0_uniq_check{inv_host}{'common'}{bridge_name}=conf_id; #if bridge_name ne 'no' and vlan_id eq 'no'.
    #$cfg0_uniq_check{inv_host}{'common'}{ipaddr}=conf_id; #if ipaddr_opts ne 'dhcp'.
    ###
    #Checks (uniq) for vlan interfaces at current inv_host.
    #$cfg0_uniq_check{inv_host}{'vlan'}{vlan_id}=conf_id; #if vlan_id ne 'no'.
    #$cfg0_uniq_check{inv_host}{'vlan'}{interface_name-vlan_id}=conf_id; #if vlan_id ne 'no'.
    #$cfg0_uniq_check{inv_host}{'vlan'}{hwaddr-vlan_id}=conf_id; #if vlan_id ne 'no'.
    #$cfg0_uniq_check{inv_host}{'vlan'}{bond_name-vlan_id}=conf_id; #if vlan_id ne 'no' and bond_name ne 'no'.
    #$cfg0_uniq_check{inv_host}{'vlan'}{bridge_name-vlan_id}=conf_id; #if vlan_id ne 'no' and bridge_name ne 'no'.
    ###
    #Checks (uniq) for interfaces at config (for all inv_hosts)
    #$cfg0_uniq_check{'all_hosts'}{hwaddr}=inv_host;
    #$cfg0_uniq_check{'all_hosts'}{ipaddr}=inv_host; #if ipaddr ne 'dhcp'.
    ######
    my %defroute_check_l=();
    #$defroute_check_l{inv_host}=conf_id;

    my ($inv_host_l,$conf_id_l,$conf_type_l,$int_list_str_l,$hwaddr_list_str_l,$vlan_id_l,$bond_name_l,$bridge_name_l,$ipaddr_opts_l,$bond_opts_l,$defroute_l)=(undef,undef,undef,undef,undef,undef,undef,undef,undef,undef,undef);
        
    open(CONF,'<',$file_l);
    while ( <CONF> ) {
	$line_l=$_;
	$line_l=~s/\n$|\r$|\n\r$|\r\n$//g;
	while ($line_l=~/\t/) { $line_l=~s/\t/ /g; }
	$line_l=~s/\s+/ /g;
	$line_l=~s/^ //g;
	if ( length($line_l)>0 && $line_l!~/^\#/ ) {
    	    $line_l=~s/ \,/\,/g;
    	    $line_l=~s/\, /\,/g;
    	    $line_l=~s/ \, /\,/g;
    	    
    	    $line_l=~s/ \./\./g;
    	    $line_l=~s/\. /\./g;
    	    $line_l=~s/ \. /\./g;
    	    
    	    @arr0_l=split(' ',$line_l);
    	    if ( $#arr0_l!=10 ) {
    		$return_str_l="fail [$proc_name_l]. Conf-line='$line_l' must contain 11 params. Please, check and correct config-file";
    		last;
    	    }
    	
    	    ($inv_host_l,$conf_id_l,$conf_type_l,$int_list_str_l,$hwaddr_list_str_l,$vlan_id_l,$bond_name_l,$bridge_name_l,$ipaddr_opts_l,$bond_opts_l,$defroute_l)=@arr0_l;
	
	    $hwaddr_list_str_l=lc($hwaddr_list_str_l);
    	    
    	    #######check conf_type
    	    if ( $conf_type_l!~/^just_interface$|^virt_bridge$|^just_bridge$|^just_bond$|^bond\-bridge$|^interface\-vlan$|^bridge\-vlan$|^bond\-vlan$|^bond\-bridge\-vlan$/ ) {
    		$return_str_l="fail [$proc_name_l]. Wrong conf_type='$conf_type_l'. Conf_type must be 'just_interface/virt_bridge/just_bridge/just_bond/bond-bridge/interface-vlan/bridge-vlan/bond-vlan/bond-bridge-vlan'. Please, check and correct config-file";
		last;
    	    }
	    if ( $conf_type_l=~/\-vlan$/ && $vlan_id_l eq 'no' ) {
		$return_str_l="fail [$proc_name_l]. For vlan-config-type param vlan_id must be a NUMBER. Please, check and correct config-file";
		last;
	    }
    	    #######check conf_type
    	    
    	    #######defroute check
    		#$defroute_check_l{inv_host}=conf_id;
    	    if ( !exists($defroute_check_l{$inv_host_l}) && $defroute_l eq 'yes' ) {
    		$defroute_check_l{$inv_host_l}=$conf_id_l;
    	    }
    	    elsif ( exists($defroute_check_l{$inv_host_l}) && $defroute_l eq 'yes' ) {
    		$return_str_l="fail [$proc_name_l]. Defroute for inv_host='$inv_host_l' (conf_id='$conf_id_l') is already defined by conf_id='$defroute_check_l{$inv_host_l}'. Please, check and correct config-file";
		last;
    	    }
    	    #######defroute check
    	    
    	    #######bond_name/bridge_name simple checks
    	    if ( $conf_type_l=~/^just_interface$|^interface\-vlan$/ ) {
    		if ( $bond_name_l ne 'no' ) {
    		    $return_str_l="fail [$proc_name_l]. For conf_types='just_interface/interface-vlan' bond_name must be 'no' (conf_id='$conf_id_l'). Please, check and correct config-file";
		    last;
    		}
    		if ( $bridge_name_l ne 'no' ) {
    		    $return_str_l="fail [$proc_name_l]. For conf_types='just_interface/interface-vlan' bridge_name must be 'no' (conf_id='$conf_id_l'). Please, check and correct config-file";
		    last;
    		}
    	    }
    	    
    	    if ( $conf_type_l=~/^virt_bridge$|^just_bridge$|^bridge\-vlan$/ ) {
    		if ( $bond_name_l ne 'no' ) {
    		    $return_str_l="fail [$proc_name_l]. For conf_types='virt_bridge/just_bridge/bridge-vlan' bond_name must be 'no' (conf_id='$conf_id_l'). Please, check and correct config-file";
		    last;
    		}
    		if ( $bridge_name_l eq 'no' ) {
    		    $return_str_l="fail [$proc_name_l]. For conf_types='virt_bridge/just_bridge/bridge-vlan' bridge_name must be NOT 'no'. Please, check and correct config-file";
		    last;
    		}
    	    }
    	    
    	    if ( $conf_type_l=~/^just_bond$|^bond\-vlan$/ ) {
    		if ( $bridge_name_l ne 'no' ) {
    		    $return_str_l="fail [$proc_name_l]. For conf_types='just_bond/bond-vlan' bridge_name must be 'no' (conf_id='$conf_id_l'). Please, check and correct config-file";
		    last;
    		}
    		if ( $bond_name_l eq 'no' ) {
    		    $return_str_l="fail [$proc_name_l]. For conf_types='just_bond/bond-vlan' bond_name must be NOT 'no'. Please, check and correct config-file";
		    last;
    		}
    	    }
    	    
    	    if ( $conf_type_l=~/^bond\-bridge$|^bond\-bridge\-vlan$/ ) {
    		if ( $bridge_name_l eq 'no' ) {
    		    $return_str_l="fail [$proc_name_l]. For conf_types='bond-bridge/bond-bridge-vlan' bridge_name must be NOT 'no'. Please, check and correct config-file";
		    last;
    		}
    		if ( $bond_name_l eq 'no' ) {
    		    $return_str_l="fail [$proc_name_l]. For conf_types='bond-bridge/bond-bridge-vlan' bond_name must be NOT 'no'. Please, check and correct config-file";
		    last;
    		}
    	    }
    	    #######bond_name/bridge_name simple checks
	    
    	    #######IPADDRv4 PREcheck via regexp
    	    if ( $conf_type_l!~/^virt_bridge$/ && $ipaddr_opts_l!~/^dhcp$|^\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}\,\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}\,\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}$/ ) {
    		$return_str_l="fail [$proc_name_l]. IPv4_ADDR_OPTS must be 'dhcp' or 'ipv4,gw,netmask' (conf_id='$conf_id_l'). Please, check and correct config-file";
		last;
    	    }
    	    elsif ( $conf_type_l=~/^virt_bridge$/ && $ipaddr_opts_l!~/^\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}\,nogw\,\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}$/ ) {
    		$return_str_l="fail [$proc_name_l]. IPv4_ADDR_OPTS for conf_type='virt-bridge' (conf_id='$conf_id_l') must be 'ipv4,nogw,netmask' (for example '10.1.1.1,nogw,255.255.255.0'). Please, check and correct config-file";
		last;
    	    }
    	    #######IPADDRv4 PREcheck via regexp
	    
    	    #######extract complex vars
    	    @int_list_arr_l=split(/\,/,$int_list_str_l);
    	    @hwaddr_list_arr_l=split(/\,/,$hwaddr_list_str_l);
    	    @ipaddr_opts_arr_l=split(/\,/,$ipaddr_opts_l);
	    $bond_opts_str_l=$bond_opts_str_def_l;
    	    if ( $conf_type_l=~/^just_bond$|^bond\-vlan$|^bond\-bridge$|^bond\-bridge\-vlan$/ && $bond_opts_l!~/^def$/ ) {
    		$bond_opts_str_l=$bond_opts_l;
    		$bond_opts_str_l=~s/\,/ /g;
    	    }
    	    #######extract complex vars
	    
	    #######CHECK if ip=gw
	    if ( $ipaddr_opts_arr_l[0] eq $ipaddr_opts_arr_l[1] ) {
		$return_str_l="fail [$proc_name_l]. It is deny to set ip=gw (conf_id='$conf_id_l'). Please, check and correct config-file";
		last;
	    }
	    #######CHECK if ip=gw
    	    
    	    #######interfaces + hwaddr count checks for each conf_type
    	    if ( $conf_type_l=~/^virt_bridge$/ ) { #for conf_type=virt_bridge. No interfaces
    		if ( $#hwaddr_list_arr_l!=0 ) {
    		    $return_str_l="fail [$proc_name_l]. For conf_type='$conf_type_l' must be configured only one HWADDR (conf_id='$conf_id_l'). Please, check and correct config-file";
		    last;
    		}
    		if ( $#int_list_arr_l>0 or $int_list_arr_l[0] ne 'no' ) {
    		    $return_str_l="fail [$proc_name_l]. For conf_type='$conf_type_l' int_list must contain only 'no' (conf_id='$conf_id_l'). Please, check and correct config-file";
		    last;
    		}
    	    }
    	    
    	    if ( $conf_type_l=~/^just_interface$|^interface\-vlan$|^bridge\-vlan$/ ) { #for conf_types where possible using only one interface
		# prev = $conf_type_l=~/^just_interface$|^just_bridge$|^interface\-vlan$|^bridge\-vlan$/
    		if ( ($#int_list_arr_l==$#hwaddr_list_arr_l && $#int_list_arr_l!=0) or $#int_list_arr_l!=$#hwaddr_list_arr_l ) {
    		    $return_str_l="fail [$proc_name_l]. For conf_type='$conf_type_l' must be configured only one HWADDR (conf_id='$conf_id_l'). Please, check and correct config-file";
		    last;
    		}
    		if ( $int_list_arr_l[0] eq 'no' ) {
    		    $return_str_l="fail [$proc_name_l]. For conf_type='$conf_type_l' int_list must contain interface names, but not 'no' (conf_id='$conf_id_l'). Please, check and correct config-file";
		    last;
    		}
    	    }
    	    
    	    if ( $conf_type_l=~/^just_bond$|^bond\-bridge$|^bond\-vlan$|^bond\-bridge\-vlan$/ ) { #for conf_types where >=2 interfaces
    		if ( $#int_list_arr_l<1 or $#int_list_arr_l!=$#hwaddr_list_arr_l ) {
    		    $return_str_l="fail [$proc_name_l]. For conf_type='$conf_type_l' amount of interfaces must = amount of hwaddr and amount of interfaces must be >= 2 (conf_id='$conf_id_l'). Please, check and correct config-file";
		    last;
    		}
    		foreach $arr_el0_l ( @int_list_arr_l ) {
    		    if ( $arr_el0_l eq 'no' ) {
    			$return_str_l="fail [$proc_name_l]. For conf_type='$conf_type_l' int_list must contain interface names, but not 'no' (conf_id='$conf_id_l'). Please, check and correct config-file";
    			last;
    		    }
    		}
    		$arr_el0_l=undef;
    	    }
	    
	    if ( $return_str_l!~/^OK$/ ) { last; }
    	    #######interfaces + hwaddr count checks for each conf_type
    	    
    	    #######hwaddr check via regexp
	    if ( $conf_type_l!~/^virt_bridge$/ ) {
    		foreach $arr_el0_l ( @hwaddr_list_arr_l ) {
    		    if ( $arr_el0_l!~/^\S{2}\:\S{2}\:\S{2}\:\S{2}\:\S{2}\:\S{2}$/ ) {
    			$return_str_l="fail [$proc_name_l]. HWADDR must be like 'XX:XX:XX:XX:XX:XX' (incorrect value='$arr_el0_l') (conf_id='$conf_id_l'). Please, check and correct config-file";
			last;
    		    }
    		}
	    }
	    else {
		foreach $arr_el0_l ( @hwaddr_list_arr_l ) {
    		    if ( $arr_el0_l!~/^no$/ ) {
    			$return_str_l="fail [$proc_name_l]. HWADDR for virt_bridge must be 'no' (incorrect value='$arr_el0_l') (conf_id='$conf_id_l'). Please, check and correct config-file";
			last;
    		    }
    		}
	    }
	    
	    if ( $return_str_l!~/^OK$/ ) { last; }
    	    #######hwaddr check via regexp
    	    
	    #######NETWORK DATA (ip link) checks
	    if ( $conf_type_l!~/^virt_bridge$/ ) {
		#our %inv_hosts_network_data_g=();
		#read 'ip_link_noqueue' first
		#v1) key0='hwaddr_all', key1=hwaddr, value=inv_host
		#v2) key0='inv_host', key1=inv_host, key2=interface_name, key3=hwaddr
		for ( $arr_i0_l=0; $arr_i0_l<=$#hwaddr_list_arr_l; $arr_i0_l++ ) {
		    if ( exists(${$inv_hosts_network_data_href_l}{'hwaddr_all'}{$hwaddr_list_arr_l[$arr_i0_l]}) && $inv_host_l ne ${$inv_hosts_network_data_href_l}{'hwaddr_all'}{$hwaddr_list_arr_l[$arr_i0_l]} ) {
			$return_str_l="fail [$proc_name_l]. NETWORK DATA check. HWADDR='$hwaddr_list_arr_l[$arr_i0_l]' configured for inv_host='$inv_host_l' is already used by host='${$inv_hosts_network_data_href_l}{'hwaddr_all'}{$hwaddr_list_arr_l[$arr_i0_l]}' (conf_id='$conf_id_l'). Please, check and correct config-file or solve problem with duplicated mac-address";
			last;
		    }
		    
		    if ( !exists(${$inv_hosts_network_data_href_l}{'inv_host'}{$inv_host_l}{$int_list_arr_l[$arr_i0_l]}{$hwaddr_list_arr_l[$arr_i0_l]}) ) {
			$return_str_l="fail [$proc_name_l]. NETWORK DATA check. At inv_host='$inv_host_l' interface='$int_list_arr_l[$arr_i0_l]' not linked with hwaddr='$hwaddr_list_arr_l[$arr_i0_l]' (conf_id='$conf_id_l'). Please, check and correct config-file";
			last;
		    }
		}
		
		if ( $return_str_l!~/^OK$/ ) { last; }
	    }
	    #######NETWORK DATA (ip link) checks
	    
    	    #######uniq checks for all hosts (hwaddr, ipaddr)
    		#$cfg0_uniq_check{'all_hosts'}{hwaddr}=inv_host;
    		#$cfg0_uniq_check{'all_hosts'}{ipaddr}=inv_host; #if ipaddr ne 'dhcp'.
    	    foreach $arr_el0_l ( @hwaddr_list_arr_l ) {
    		if ( !exists($cfg0_uniq_check_l{'all_hosts'}{$arr_el0_l}) ) {
    		    $cfg0_uniq_check_l{'all_hosts'}{$arr_el0_l}=$inv_host_l;
    		}
    		else {
    		    if ( $cfg0_uniq_check_l{'all_hosts'}{$arr_el0_l} ne $inv_host_l ) {
    			$return_str_l="fail [$proc_name_l]. Hwaddr='$arr_el0_l' is already used at host='$cfg0_uniq_check_l{'all_hosts'}{$arr_el0_l}' (conf_id='$conf_id_l'). Please, check and correct config-file";
    			last;
    		    }
    		}
    	    }
	    
	    if ( $return_str_l!~/^OK$/ ) { last; }
    	    
    	    if ( $ipaddr_opts_arr_l[0] ne 'dhcp' ) {
    		if ( !exists($cfg0_uniq_check_l{'all_hosts'}{$ipaddr_opts_arr_l[0]}) ) {
    		    $cfg0_uniq_check_l{'all_hosts'}{$ipaddr_opts_arr_l[0]}=$inv_host_l;
    		}
    		else {
    		    $return_str_l="fail [$proc_name_l]. IPaddr='$ipaddr_opts_arr_l[0]' is already used at host='$cfg0_uniq_check_l{'all_hosts'}{$ipaddr_opts_arr_l[0]}' (conf_id='$conf_id_l'). Please, check and correct config-file";
		    last;
    		}
    	    }
    	    ########uniq checks for all hosts
	    
    	    ########check for uniq bridge names
    	    if ( $bridge_name_l ne 'no' ) {
    	    	if ( !exists($cfg0_uniq_check_l{$inv_host_l}{'common'}{$bridge_name_l}) ) {
    	    	    $cfg0_uniq_check_l{$inv_host_l}{'common'}{$bridge_name_l}=$conf_id_l;
    	    	}
    	    	else {
    	    	    $return_str_l="fail [$proc_name_l]. Bridge_name='$bridge_name_l' (inv_host='$inv_host_l', conf_id='$conf_id_l') is already used at config with id='".$cfg0_uniq_check_l{$inv_host_l}{'common'}{$bridge_name_l}."'. Please, check and correct config-file";
    	    	    last;
    	    	}
    	    }
    	    ########check for uniq bridge names

    	    ########uniq checks (for local params of hosts)
    	    if ( $vlan_id_l=~/^no$/ ) { #if novlan
    	    	###$cfg0_uniq_check{inv_host}{'common'}{interface_name}=conf_id; #if interface_name ne 'no' and vlan_id eq 'no'.
    	    	foreach $arr_el0_l ( @int_list_arr_l ) {
    	    	    if ( $arr_el0_l=~/^no$/ ) { last; }
    	    	    if ( !exists($cfg0_uniq_check_l{$inv_host_l}{'common'}{$arr_el0_l}) ) {
    	    		$cfg0_uniq_check_l{$inv_host_l}{'common'}{$arr_el0_l}=$conf_id_l;
    	    	    }
    	    	    else {
    	    		$return_str_l="fail [$proc_name_l]. Interface_name='$arr_el0_l' (inv_host='$inv_host_l', conf_id='$conf_id_l') is already used at config with id='$cfg0_uniq_check_l{$inv_host_l}{'common'}{$arr_el0_l}'. Please, check and correct config-file";
	    		last;
    	    	    }
    	    	}
	    	
	    	if ( $return_str_l!~/^OK$/ ) { last; }
    	    	###
	    	
    	    	###$cfg0_uniq_check{inv_host}{'common'}{hwaddr}=conf_id; if vlan_id eq 'no'.
    	    	foreach $arr_el0_l ( @hwaddr_list_arr_l ) {
    	    	    if ( !exists($cfg0_uniq_check_l{$inv_host_l}{'common'}{$arr_el0_l}) ) {
    	    		$cfg0_uniq_check_l{$inv_host_l}{'common'}{$arr_el0_l}=$conf_id_l;
    	    	    }
    	    	    else {
    	    		$return_str_l="fail [$proc_name_l]. Hwaddr='$arr_el0_l' (inv_host='$inv_host_l', conf_id='$conf_id_l') is already used at config with id='$cfg0_uniq_check_l{$inv_host_l}{'common'}{$arr_el0_l}'. Please, check and correct config-file";
	    		last;
    	    	    }
    	    	}
	    	
	    	if ( $return_str_l!~/^OK$/ ) { last; }
    	    	###
    	    	
    	    	###$cfg0_uniq_check{inv_host}{'common'}{bond_name}=conf_id; #if bond_name ne 'no' and vlan_id eq 'no'.
    	    	if ( $bond_name_l ne 'no' ) {
    	    	    if ( !exists($cfg0_uniq_check_l{$inv_host_l}{'common'}{$bond_name_l}) ) {
    	    		$cfg0_uniq_check_l{$inv_host_l}{'common'}{$bond_name_l}=$conf_id_l;
    	    	    }
    	    	    else {
    	    		$return_str_l="fail [$proc_name_l]. Bond_name='$bond_name_l' (inv_host='$inv_host_l', conf_id='$conf_id_l') is already used at config with id='$cfg0_uniq_check_l{$inv_host_l}{'common'}{$bond_name_l}'. Please, check and correct config-file";
    	    		last;
    	    	    }
    	    	}
    	    	###
    	    	
    	    	###$cfg0_uniq_check{inv_host}{'common'}{ipaddr}=conf_id; #if ipaddr_opts ne 'dhcp'.
    	    	if ( $ipaddr_opts_arr_l[0] ne 'dhcp' ) {
    	    	    if ( !exists($cfg0_uniq_check_l{$inv_host_l}{'common'}{$ipaddr_opts_arr_l[0]}) ) {
    	    	        $cfg0_uniq_check_l{$inv_host_l}{'common'}{$ipaddr_opts_arr_l[0]}=$conf_id_l;
    	    	    }
    	    	    else {
    	    		$return_str_l="fail [$proc_name_l]. Ipaddr='$ipaddr_opts_arr_l[0]' (inv_host='$inv_host_l', conf_id='$conf_id_l') is already used at config with id='$cfg0_uniq_check_l{$inv_host_l}{'common'}{$ipaddr_opts_arr_l[0]}'. Please, check and correct config-file";
	    		last;
    	    	    }
    	    	}
    	    	###
    	    }
    	    else { #if vlan
    	    	###$cfg0_uniq_check{inv_host}{'vlan'}{vlan_id}=conf_id; #if vlan_id ne 'no'.
    	    	if ( !exists($cfg0_uniq_check_l{$inv_host_l}{'vlan'}{$vlan_id_l}) ) {
    	    	    $cfg0_uniq_check_l{$inv_host_l}{'vlan'}{$vlan_id_l}=$conf_id_l;
    	    	}
    	    	else {
    	    	    $return_str_l="fail [$proc_name_l]. Vlan_id='$vlan_id_l' (inv_host='$inv_host_l', conf_id='$conf_id_l') is already used at config with id='$cfg0_uniq_check_l{$inv_host_l}{'vlan'}{$vlan_id_l}'. Please, check and correct config-file";
	    	    last;
    	    	}
    	    	###
    	    	
    	    	###$cfg0_uniq_check{inv_host}{'vlan'}{interface_name-vlan_id}=conf_id; #if vlan_id ne 'no'.
    	    	foreach $arr_el0_l ( @int_list_arr_l ) {
    	    	    if ( $arr_el0_l=~/^no$/ ) { last; }
    	    	    if ( !exists($cfg0_uniq_check_l{$inv_host_l}{'vlan'}{$arr_el0_l.'-'.$vlan_id_l}) ) {
    	    		$cfg0_uniq_check_l{$inv_host_l}{'vlan'}{$arr_el0_l.'-'.$vlan_id_l}=$conf_id_l;
    	    	    }
    	    	    else {
    	    		$return_str_l="fail [$proc_name_l]. Interface_name='$arr_el0_l' (inv_host='$inv_host_l', conf_id='$conf_id_l', vlan_id='$vlan_id_l') is already used at config with id='".$cfg0_uniq_check_l{$inv_host_l}{'vlan'}{$arr_el0_l.'-'.$vlan_id_l}."'. Please, check and correct config-file";
	    		last;
    	    	    }
    	    	}
	    	
	    	if ( $return_str_l!~/^OK$/ ) { last; }
    	    	###
    	    	
    	    	###$cfg0_uniq_check{inv_host}{'vlan'}{hwaddr-vlan_id}=conf_id; #if vlan_id ne 'no'.
    	    	foreach $arr_el0_l ( @hwaddr_list_arr_l ) {
    	    	    if ( !exists($cfg0_uniq_check_l{$inv_host_l}{'vlan'}{$arr_el0_l.'-'.$vlan_id_l}) ) {
    	    		$cfg0_uniq_check_l{$inv_host_l}{'vlan'}{$arr_el0_l.'-'.$vlan_id_l}=$conf_id_l;
    	    	    }
    	    	    else {
    	    	        $return_str_l="fail [$proc_name_l]. Hwaddr='$arr_el0_l' (inv_host='$inv_host_l', conf_id='$conf_id_l', vlan_id='$vlan_id_l') is already used at config with id='".$cfg0_uniq_check_l{$inv_host_l}{'vlan'}{$arr_el0_l.'-'.$vlan_id_l}."'. Please, check and correct config-file";
	    		last;
    	    	    }
    	    	}
	    	
	    	if ( $return_str_l!~/^OK$/ ) { last; }
    	    	###

                ###$cfg0_uniq_check{inv_host}{'vlan'}{bond_name-vlan_id}=conf_id; #if vlan_id ne 'no' and bond_name ne 'no'.
                if ( $bond_name_l ne 'no' ) {
                    if ( !exists($cfg0_uniq_check_l{$inv_host_l}{'vlan'}{$bond_name_l.'-'.$vlan_id_l}) ) {
                        $cfg0_uniq_check_l{$inv_host_l}{'vlan'}{$bond_name_l.'-'.$vlan_id_l}=$conf_id_l;
                    }
                    else {
                        $return_str_l="fail [$proc_name_l]. Bond_name='$bond_name_l' (inv_host='$inv_host_l', conf_id='$conf_id_l', vlan_id='$vlan_id_l') is already used at config with id='".$cfg0_uniq_check_l{$inv_host_l}{'vlan'}{$bond_name_l.'-'.$vlan_id_l}."'. Please, check and correct config-file";
                        last;
                    }
                }
                ###
    	    }
    	    ########uniq checks
    	    
    	    ########unique conf_id for inventory_host
    	    if ( !exists(${$res_href_l}{$inv_host_l.'-'.$conf_id_l}) ) {
    		#$cfg0_hash_g{$inv_host_l.'-'.$conf_id_l}{$conf_type_l}{'main'}=[$inv_host_l,$conf_id_l,$vlan_id_l,$bond_name_l,$bridge_name_l,$defroute_l];
		${$res_href_l}{$inv_host_l.'-'.$conf_id_l}{$conf_type_l}{'main'}{'_inv_host_'}=$inv_host_l;
		${$res_href_l}{$inv_host_l.'-'.$conf_id_l}{$conf_type_l}{'main'}{'_conf_id_'}=$conf_id_l;
		${$res_href_l}{$inv_host_l.'-'.$conf_id_l}{$conf_type_l}{'main'}{'_vlan_id_'}=$vlan_id_l;
		${$res_href_l}{$inv_host_l.'-'.$conf_id_l}{$conf_type_l}{'main'}{'_bridge_name_'}=$bridge_name_l;
		${$res_href_l}{$inv_host_l.'-'.$conf_id_l}{$conf_type_l}{'main'}{'_defroute_'}=$defroute_l;
		${$res_href_l}{$inv_host_l.'-'.$conf_id_l}{$conf_type_l}{'main'}{'_bond_opts_'}=$bond_opts_str_l;
    		${$res_href_l}{$inv_host_l.'-'.$conf_id_l}{$conf_type_l}{'hwaddr_list'}=[@hwaddr_list_arr_l];
		
		if ( $ipaddr_opts_arr_l[0] ne 'dhcp' ) {
		    ${$res_href_l}{$inv_host_l.'-'.$conf_id_l}{$conf_type_l}{'main'}{'_ipaddr_'}=$ipaddr_opts_arr_l[0];
		    ${$res_href_l}{$inv_host_l.'-'.$conf_id_l}{$conf_type_l}{'main'}{'_gw_'}=$ipaddr_opts_arr_l[1];
		    ${$res_href_l}{$inv_host_l.'-'.$conf_id_l}{$conf_type_l}{'main'}{'_netmask_'}=$ipaddr_opts_arr_l[2];
		}
		else {
		    ${$res_href_l}{$inv_host_l.'-'.$conf_id_l}{$conf_type_l}{'main'}{'_ipaddr_'}='dhcp';
		    ${$res_href_l}{$inv_host_l.'-'.$conf_id_l}{$conf_type_l}{'main'}{'_gw_'}='dhcp';
		    ${$res_href_l}{$inv_host_l.'-'.$conf_id_l}{$conf_type_l}{'main'}{'_netmask_'}='dhcp';
		}
		
		${$res_href_l}{$inv_host_l.'-'.$conf_id_l}{$conf_type_l}{'main'}{'_bond_name_'}=$bond_name_l;
		${$res_href_l}{$inv_host_l.'-'.$conf_id_l}{$conf_type_l}{'int_list'}=[@int_list_arr_l];
		
		if ( $conf_type_l=~/vlan$/ && $vlan_id_l ne 'no' ) { # redifine interface/bond names if VLAN
		    if ( $bond_name_l eq 'no' ) { # for cases there vlan applied to interface (interface-vlan, bridge-vlan)
			${$res_href_l}{$inv_host_l.'-'.$conf_id_l}{$conf_type_l}{'main'}{'_bond_name_'}=$bond_name_l;
			foreach $arr_el0_l (@{${$res_href_l}{$inv_host_l.'-'.$conf_id_l}{$conf_type_l}{'int_list'}}) { $arr_el0_l.='.'.$vlan_id_l; }
		    }
		    elsif ( $bond_name_l ne 'no' ) { # for cases there vlan applied to bond (bond-vlan, bond-bridge-vlan)
			${$res_href_l}{$inv_host_l.'-'.$conf_id_l}{$conf_type_l}{'main'}{'_bond_name_'}=$bond_name_l.'.'.$vlan_id_l;
		    }
		}
    	    }
    	    else {
    		$return_str_l="fail [$proc_name_l]. For inv_host='$inv_host_l' conf_id='$conf_id_l' is already exists. Please, check and correct config-file";
    		last;
    	    }
    	    ########unique conf_id for inventory_host
	    
	    #############
	    @int_list_arr_l=();
	    @hwaddr_list_arr_l=();
	    @ipaddr_opts_arr_l=();
	    	
	    @arr0_l=();
	    ($inv_host_l,$conf_id_l,$conf_type_l,$int_list_str_l,$hwaddr_list_str_l,$vlan_id_l,$bond_name_l,$bridge_name_l,$ipaddr_opts_l,$bond_opts_l,$defroute_l)=(undef,undef,undef,undef,undef,undef,undef,undef,undef,undef,undef);
	    #############
	}
	$line_l=undef;
    }
    close(CONF);
    
    if ( $return_str_l!~/^OK$/ ) { return $return_str_l; }
}

sub recreate_ifcfg_tmplt_based_on_cfg0_hash {
    my ($dyn_ifcfg_common_dir_l,$ifcfg_tmplt_dir_l,$cfg0_hash_href_l,$conf_type_sub_refs_href_l,$res_inv_hosts_hash0_href_l)=@_;
    my $proc_name_l=(caller(0))[3];
    #$dyn_ifcfg_common_dir_l=$dyn_ifcfg_common_dir_g
    #$ifcfg_tmplt_dir_l=$ifcfg_tmplt_dir_g
    #cfg0_hash_href_l=hash ref for %cfg0_hash_g
    #$conf_type_sub_refs_href_l=hash ref for %conf_type_sub_refs_g
    #res_href_inv_hosts_hash0_l=hash ref for %inv_hosts_hash0_g
    
    my ($hkey0_l,$hval0_l)=(undef,undef);
    my ($hkey1_l,$hval1_l)=(undef,undef);
    my ($inv_host_l,$conf_id_l)=(undef,undef);
    
    my $return_str_l='OK';
    
    ###remove prev generated ifcfg
    if ( -d $dyn_ifcfg_common_dir_l ) {
	system("cd $dyn_ifcfg_common_dir_l && ls | grep -v 'info' | xargs rm -rf");
    }
    ###remove prev generated ifcfg
    
    while ( ($hkey0_l,$hval0_l)=each %{$cfg0_hash_href_l} ) {
	#$hkey0_h = inv_host-conf_id
	($inv_host_l,$conf_id_l)=split(/\-/,$hkey0_l);
	${$res_inv_hosts_hash0_href_l}{$inv_host_l}=1;
	
	system("mkdir -p ".$dyn_ifcfg_common_dir_l.'/'.$inv_host_l.'/fin');
	system("mkdir -p ".$dyn_ifcfg_common_dir_l.'/'.$inv_host_l.'/'.$conf_id_l);
	
	while ( ($hkey1_l,$hval1_l)=each %{$hval0_l} ) {
	    #$hkey1_l = conf_type, $hval1_l = hash ref
	    if ( -d $ifcfg_tmplt_dir_l.'/'.$hkey1_l ) {
		&{${$conf_type_sub_refs_href_l}{$hkey1_l}}($ifcfg_tmplt_dir_l.'/'.$hkey1_l,$dyn_ifcfg_common_dir_l.'/'.$inv_host_l.'/'.$conf_id_l,$hval1_l);
		######
		#$cfg0_hash_g{inv_host-conf_id}{conf_type}-HREF->{'main'}{'_inv_host_'}=inv_host;
		#$cfg0_hash_g{inv_host-conf_id}{conf_type}-HREF->{'main'}{'_conf_id_'}=conf_id;
		#$cfg0_hash_g{inv_host-conf_id}{conf_type}-HREF->{'main'}{'_vlan_id_'}=vlan_id;
		#$cfg0_hash_g{inv_host-conf_id}{conf_type}-HREF->{'main'}{'_bond_name_'}=bond_name;
		#$cfg0_hash_g{inv_host-conf_id}{conf_type}-HREF->{'main'}{'_bridge_name_'}=bridge_name;
		#$cfg0_hash_g{inv_host-conf_id}{conf_type}-HREF->{'main'}{'_defroute_'}=defroute;
		#$cfg0_hash_g{inv_host-conf_id}{conf_type}-HREF->{'main'}{'_ipaddr_'}=ipaddr/dhcp;
		#$cfg0_hash_g{inv_host-conf_id}{conf_type}-HREF->{'main'}{'_gw_'}=gw/dhcp;
		#$cfg0_hash_g{inv_host-conf_id}{conf_type}-HREF->{'main'}{'_netmask_'}=gw/dhcp;
		#$cfg0_hash_g{inv_host-conf_id}{conf_type}-HREF->{'main'}{'_bond_opts_'}=bond_opts_string_for_ifcfg;
		#$cfg0_hash_g{inv_host-conf_id}{conf_type}-HREF->{'int_list'}=[array of interfaces];
		#$cfg0_hash_g{inv_host-conf_id}{conf_type}-HREF->{'hwaddr_list'}=[array of hwaddr];
		
		system("cp $dyn_ifcfg_common_dir_l/$inv_host_l/$conf_id_l/* $dyn_ifcfg_common_dir_l/$inv_host_l/fin/");
	    }
	    else {
		$return_str_l="fail [$proc_name_l]. Ifcfg tmplt dir='$ifcfg_tmplt_dir_l/$hkey1_l' not exists";
		last;
	    }
	}
	
	($hkey1_l,$hval1_l)=(undef,undef);
	($inv_host_l,$conf_id_l)=(undef,undef);
	
	if ( $return_str_l!~/^OK$/ ) { last; }
    }
    
    ($hkey0_l,$hval0_l)=(undef,undef);
    ($hkey1_l,$hval1_l)=(undef,undef);
    ($inv_host_l,$conf_id_l)=(undef,undef);
    
    return $return_str_l;
}

sub generate_resolv_conf_files {
    my ($conf_dns_l,$dyn_resolv_common_dir_l,$res_inv_hosts_dns_href_l)=@_;
    #$conf_dns_l=$conf_dns_g
    #$dyn_resolv_common_dir_l=$dyn_resolv_common_dir_g
    #$res_inv_hosts_dns_href_l=hash ref for %inv_hosts_dns_h
    my $proc_name_l=(caller(0))[3];
    ###READ conf file 'dns_settings' and generate resolv-conf-files
	#$dyn_resolv_common_dir_g=$self_dir_g.'playbooks/dyn_ifcfg_playbooks/dyn_resolv_conf' -> files: 'inv_host_resolv' or 'common_resolv'
	#%inv_hosts_dns_g=(); #key=inv_host/common, value=[array of nameservers]
    
    my ($line_l,$arr_el0_l)=(undef,undef);
    my ($hkey0_l,$hval0_l)=(undef,undef);
    my $return_str_l='OK';
    
    open(CONF_DNS,'<',$conf_dns_l);
    while ( <CONF_DNS> ) {
	$line_l=$_;
	$line_l=~s/\n$|\r$|\n\r$|\r\n$//g;
	while ($line_l=~/\t/) { $line_l=~s/\t/ /g; }
	$line_l=~s/\s+/ /g;
	$line_l=~s/^ //g;
	if ( length($line_l)>0 && $line_l!~/^\#/ && $line_l=~/^(\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}|common) (\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3})$/ ) {
	    push(@{${$res_inv_hosts_dns_href_l}{$1}},$2);
	}
    }
    close(CONF_DNS);
    
    $line_l=undef;
    ######
    if ( -d $dyn_resolv_common_dir_l ) {
	system("cd $dyn_resolv_common_dir_l && ls | grep -v 'info' | xargs rm -rf");
    }
    
    while ( ($hkey0_l,$hval0_l)=each %{$res_inv_hosts_dns_href_l} ) {
	#hkey0_l=inv_host
	open(RESOLV,'>',$dyn_resolv_common_dir_l.'/'.$hkey0_l.'_resolv');
	print RESOLV "# Generated by ansible scenario 'conf_int_ipv4_via_network_scripts'\n";
	foreach $arr_el0_l ( @{$hval0_l} ) {
	    print RESOLV "nameserver $arr_el0_l\n";
	}
	close(RESOLV);
	
	$arr_el0_l=undef;
    }
    
    $arr_el0_l=undef;
    ($hkey0_l,$hval0_l)=(undef,undef);
    ###READ conf file 'dns_settings' and generate resolv-conf-files
    
    return $return_str_l;
}

sub read_config_del_not_configured_ifcfg {
    my ($file_l,$res_href_l)=@_;
    #$file_l=$conf_file_del_not_configured_g
    #$res_href_l=hash ref for %inv_hosts_ifcfg_del_not_configured_g
    my $proc_name_l=(caller(0))[3];
    
    #%inv_hosts_ifcfg_del_not_configured_g=(); #for config 'config_del_not_configured_ifcfg'. Key=inv_host
    
    my $line_l=undef;
    my $return_str_l='OK';
    
    open(CONF_DEL,'<',$file_l);
    while ( <CONF_DEL> ) {
	$line_l=$_;
	$line_l=~s/\n$|\r$|\n\r$|\r\n$//g;
	while ($line_l=~/\t/) { $line_l=~s/\t/ /g; }
	$line_l=~s/\s+/ /g;
	$line_l=~s/^ //g;
	if ( length($line_l)>0 && $line_l!~/^\#/ && $line_l=~/^(\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3})$/ ) {
	    ${$res_href_l}{$1}=1;
	}
    }
    close(CONF_DEL);
    
    $line_l=undef;
    
    return $return_str_l;
}

sub read_config_temporary_apply_ifcfg {
    my ($file_l,$res_href_l)=@_;
    #file_l=conf_temp_apply_g
    #res_href_l=hash ref for %inv_hosts_tmp_apply_cfg_g
    my $proc_name_l=(caller(0))[3];
    
    #%inv_hosts_tmp_apply_cfg_g=(); #key=inv_host/common, value=rollback_ifcfg_timeout
    
    my $line_l=undef;
    my $return_str_l='OK';
    
    open(CONF_TMP_APPLY,'<',$file_l);
    while ( <CONF_TMP_APPLY> ) {
	$line_l=$_;
	$line_l=~s/\n$|\r$|\n\r$|\r\n$//g;
	while ($line_l=~/\t/) { $line_l=~s/\t/ /g; }
	$line_l=~s/\s+/ /g;
	$line_l=~s/^ //g;
	if ( length($line_l)>0 && $line_l!~/^\#/ && $line_l=~/^(\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}|common) (\d+)$/ ) {
	    ${$res_href_l}{$1}=$2;
	}
    }
    close(CONF_TMP_APPLY);
    
    $line_l=undef;
    
    return $return_str_l;
}

sub fill_inv_hosts_hash1_with_fin_n_now_dirs {
    my ($dyn_ifcfg_common_dir_l,$ifcfg_backup_from_remote_dir_l,$inv_hosts_hash0_href_l,$res_href_l)=@_;
    #$dyn_ifcfg_common_dir_l=$dyn_ifcfg_common_dir_g
    #$ifcfg_backup_from_remote_dir_l=$ifcfg_backup_from_remote_dir_g
    #$inv_hosts_hash0_href_l=hash ref for %inv_hosts_hash0_g
    #$res_href_l=hash ref for %inv_hosts_hash1_g
    my $proc_name_l=(caller(0))[3];
    
    my $line_l=undef;
    my $is_wireless_interface_l=0; # if == 1 (is wireless interface) -> ignore (no add to res_href_l)
    my ($hkey0_l,$hval0_l)=(undef,undef);
    my $return_str_l='OK';
    
    while ( ($hkey0_l,$hval0_l)=each %{$inv_hosts_hash0_href_l} ) {
	#hkey0_g=inv_host
	opendir(DIR_FIN,$dyn_ifcfg_common_dir_l.'/'.$hkey0_l.'/fin');
	while ( readdir DIR_FIN ) {
	    $line_l=$_;
	    if ( $line_l!~/^\./ ) {
		${$res_href_l}{$hkey0_l}{'fin'}{$line_l}=1;
	    }
	}
	closedir(DIR_FIN);
	
	opendir(DIR_NOW,$ifcfg_backup_from_remote_dir_l.'/'.$hkey0_l);
	while ( readdir DIR_NOW ) {
	    $line_l=$_;
	    if ( $line_l=~/^\./ ) { next; }
	    
	    $is_wireless_interface_l=`grep -i 'TYPE=Wireless' "$ifcfg_backup_from_remote_dir_l/$hkey0_l/$line_l" | wc -l`;
	    
	    if ( $line_l!~/^\.|^ifcfg\-lo$/ && $is_wireless_interface_l!=1 ) {
		${$res_href_l}{$hkey0_l}{'now'}{$line_l}=1;
	    }
	    
	    # clear vars
	    $line_l=undef;
	    $is_wireless_interface_l=0;
	    ###
	}
	closedir(DIR_NOW);
	
	delete(${$inv_hosts_hash0_href_l}{$hkey0_l});
    }
    
    $line_l=undef;
    ($hkey0_l,$hval0_l)=(undef,undef);
    
    return $return_str_l;
}

sub modify_inv_hosts_hash1 {
    my ($dyn_ifcfg_common_dir_l,$ifcfg_backup_from_remote_dir_l,$ifcfg_backup_from_remote_nd_file_l,$inv_hosts_ifcfg_del_not_configured_href_l,$res_href_l)=@_;
    #$dyn_ifcfg_common_dir_l=$dyn_ifcfg_common_dir_g
    #$ifcfg_backup_from_remote_dir_l=$ifcfg_backup_from_remote_dir_g
    #$ifcfg_backup_from_remote_nd_file_l=$ifcfg_backup_from_remote_nd_file_g
    #$inv_hosts_ifcfg_del_not_configured_href_l=hash ref for %inv_hosts_ifcfg_del_not_configured_g
    #$res_href_l=hash ref for %inv_hosts_hash1_g
    my $proc_name_l=(caller(0))[3];
    
    my ($hkey0_l,$hval0_l)=(undef,undef);
    my ($hkey1_l,$hval1_l)=(undef,undef);
    my ($tmp_var_l,$exec_res_l)=(undef,undef);
    my $return_str_l='OK';

    #%inv_hosts_hash1_g=(); #key0=inv_host, key1=now/fin (generated by this script)/for_upd/for_del, key2=ifcfg_name
    while ( ($hkey0_l,$hval0_l)=each %{$res_href_l} ) {
	#hkey0_l=inv_host, hval0_l=hash
	while ( ($hkey1_l,$hval1_l)=each %{${$hval0_l}{'fin'}} ) { #just only configure interfaces from 'config'
	    #hkey1_l=ifcfg_name
	    if ( !exists(${$hval0_l}{'now'}{$hkey1_l}) ) { #new interface -> for_upd
	        ${$res_href_l}{$hkey0_l}{'for_upd'}{$hkey1_l}=1;
	    }
	    else {
		$exec_res_l=&ifcfg_diff_with_zone_param_save("$dyn_ifcfg_common_dir_l/$hkey0_l/fin/$hkey1_l","$ifcfg_backup_from_remote_dir_l/$hkey0_l/$hkey1_l");
		#$ifcfg_generated_file_l,$ifcfg_from_remote_file_l
		
		if ( $exec_res_l>0 ) { #if generated ifcfg (fin) not eq actual (now) -> for_upd
		    ${$res_href_l}{$hkey0_l}{'for_upd'}{$hkey1_l}=1;
		}
	    }
	}
	($hkey1_l,$hval1_l)=(undef,undef);
	
	if ( exists(${$inv_hosts_ifcfg_del_not_configured_href_l}{$hkey0_l}) ) { #if need to configure AND to delete not configured at 'config' interfaces
	    while ( ($hkey1_l,$hval1_l)=each %{${$hval0_l}{'now'}} ) {
		#hkey1_l=ifcfg_name
		
		#$ifcfg_backup_from_remote_nd_file_l = file for grep-check. If ifcfg-int at this file for cur inv_host -> no 'ip link delete'
		if ( !exists(${$hval0_l}{'fin'}{$hkey1_l}) ) { #interface for delete -> for_del
		    $tmp_var_l=$hkey1_l;
		    $tmp_var_l=~s/^ifcfg\-//g;
		    $exec_res_l=`grep -a $hkey0_l $ifcfg_backup_from_remote_nd_file_l | grep $tmp_var_l | wc -l`;
		    $exec_res_l=~s/\n|\r|\n\r|\r\n//g;
		    $exec_res_l=int($exec_res_l);
		    
		    ${$res_href_l}{$hkey0_l}{'for_del'}{$hkey1_l}=1; # just shutdown and delete ifcfg-file
		    
		    if ( $exec_res_l!=1 ) {
		    	${$res_href_l}{$hkey0_l}{'for_del_ip_link'}{$tmp_var_l}=1; # if included (means not interface-ifcfg) -> 'ip link delete'
		    }
		    
		    ($tmp_var_l,$exec_res_l)=(undef,undef);
		}
	    }
	    ($hkey1_l,$hval1_l)=(undef,undef);
	    ($tmp_var_l,$exec_res_l)=(undef,undef);
	}
    }
    ($hkey0_l,$hval0_l)=(undef,undef);
    ($hkey1_l,$hval1_l)=(undef,undef);
    
    return $return_str_l;
}

sub generate_dynamic_playbooks {
    my ($dyn_ifcfg_playbooks_dir_l,$remote_dir_for_absible_helper_l,$gen_playbooks_next_with_rollback_l,$inv_hosts_tmp_apply_cfg_href_l,$inv_hosts_dns_href_l,$inv_hosts_hash1_href_l)=@_;
    #$dyn_ifcfg_playbooks_dir_l=$dyn_ifcfg_playbooks_dir_g
    #$remote_dir_for_absible_helper_l=$remote_dir_for_absible_helper_g
    #$gen_playbooks_next_with_rollback_l=$gen_playbooks_next_with_rollback_g
    #inv_hosts_tmp_apply_cfg_href_l=hash ref for %inv_hosts_tmp_apply_cfg_g
    #inv_hosts_dns_href_l=hash ref for %inv_hosts_dns_g
    #inv_hosts_hash1_href_l=hash ref for inv_hosts_hash1_g
    my $proc_name_l=(caller(0))[3];
    
    my ($tmp_file0_l,$tmp_var_l)=(undef,undef);
    my ($hkey0_l,$hval0_l)=(undef,undef);    
    my ($hkey1_l,$hval1_l)=(undef,undef);
    my $return_str_l='OK';

    system("rm -rf ".$dyn_ifcfg_playbooks_dir_l."/*_ifcfg_change.yml");

    while ( ($hkey0_l,$hval0_l)=each %{$inv_hosts_hash1_href_l} ) {
	#hkey0_l=inv_host, hval0_l=hash
	
	$tmp_file0_l=$dyn_ifcfg_playbooks_dir_l.'/'.$hkey0_l.'_ifcfg_change.yml';
	    
	open(DYN_YML,'>',$tmp_file0_l);
	if ( exists(${$hval0_l}{'for_del'}) ) { #if need to remove ifcfg
	    print DYN_YML "- name: shutdown interfaces before delete\n";
	    print DYN_YML "  ansible.builtin.command: \"ifdown {{item}}\"\n";
	    print DYN_YML "  with_items:\n";
	    while ( ($hkey1_l,$hval1_l)=each %{${$hval0_l}{'for_del'}} ) {
		#hkey1_l=ifcfg_name
		print DYN_YML "    - $hkey1_l\n";
	    }
	    ($hkey1_l,$hval1_l)=(undef,undef);
	    print DYN_YML "\n";
	    print DYN_YML "######################################################\n";
	    print DYN_YML "\n";
	    
	    print DYN_YML "- name: delete unconfigured ifcfg-files\n";
	    print DYN_YML "  ansible.builtin.file:\n";
	    print DYN_YML "    path: \"/etc/sysconfig/network-scripts/{{item}}\"\n";
	    print DYN_YML "    state: absent\n";
	    print DYN_YML "  with_items:\n";
	    while ( ($hkey1_l,$hval1_l)=each %{${$hval0_l}{'for_del'}} ) {
		#hkey1_l=ifcfg_name
		print DYN_YML "    - $hkey1_l\n";
	    }
	    ($hkey1_l,$hval1_l)=(undef,undef);
	    print DYN_YML "\n";
	    print DYN_YML "######################################################\n";
	    print DYN_YML "\n";
	}
	
	if ( exists(${$hval0_l}{'for_del_ip_link'}) ) { # if need to 'ip link delete' (for bridges/bond ifcfg)
	    print DYN_YML "- name: ip link delete for unconfigured bridge/bonds/vlan-interfaces\n";
	    print DYN_YML "  ansible.builtin.command: \"ip link delete {{item}}\"\n";
	    print DYN_YML "  with_items:\n";
	    while ( ($hkey1_l,$hval1_l)=each %{${$hval0_l}{'for_del_ip_link'}} ) {
		#hkey1_l=link-name
		print DYN_YML "    - $hkey1_l\n";
	    }
	    ($hkey1_l,$hval1_l)=(undef,undef);
	    print DYN_YML "\n";
	    print DYN_YML "######################################################\n";
	    print DYN_YML "\n";
	}

	if ( exists(${$hval0_l}{'for_upd'}) ) { #if need to upd ifcfg
	    print DYN_YML "- name: copy/upd ifcfg-files\n";
	    print DYN_YML "  ansible.builtin.copy:\n";
	    print DYN_YML "    src: \"{{playbook_dir}}/dyn_ifcfg/{{inventory_hostname}}/fin/{{item}}\"\n";
	    print DYN_YML "    dest: \"/etc/sysconfig/network-scripts/{{item}}\"\n";
    	    print DYN_YML "    owner: root\n";
    	    print DYN_YML "    group: root\n";
    	    print DYN_YML "    mode: '0600'\n";
    	    print DYN_YML "    seuser: system_u\n";
    	    print DYN_YML "    setype: net_conf_t\n";
    	    print DYN_YML "    serole: object_r\n";
    	    print DYN_YML "    selevel: s0\n";
	    print DYN_YML "  with_items:\n";
	    if ( exists(${$hval0_l}{'for_upd'}) ) { #if need to add/upd ifcfg
		while ( ($hkey1_l,$hval1_l)=each %{${$hval0_l}{'for_upd'}} ) {
		    #hkey1_l=ifcfg_name
		    print DYN_YML "    - $hkey1_l\n";
		}
		($hkey1_l,$hval1_l)=(undef,undef);
	    }
	    print DYN_YML "\n";
	    print DYN_YML "######################################################\n";
	    print DYN_YML "\n";
	    
	    ###task for config_temporary_apply_ifcfg (FOR start RUN BEFORE network restart)
		#%inv_hosts_tmp_apply_cfg_g=(); #key=inv_host/common, value=rollback_ifcfg_timeout
	    if ( $gen_playbooks_next_with_rollback_l==1 && (exists(${$inv_hosts_tmp_apply_cfg_href_l}{$hkey0_l}) or exists(${$inv_hosts_tmp_apply_cfg_href_l}{'common'})) ) {
		#tmp_var_l=rollback_ifcfg_timeout
		if ( exists(${$inv_hosts_tmp_apply_cfg_href_l}{$hkey0_l}) ) { $tmp_var_l=${$inv_hosts_tmp_apply_cfg_href_l}{$hkey0_l}; }
		elsif ( exists(${$inv_hosts_tmp_apply_cfg_href_l}{'common'}) ) { $tmp_var_l=${$inv_hosts_tmp_apply_cfg_href_l}{'common'}; }
		
		print DYN_YML "- name: copy script 'rollback_ifcfg_changes.sh' to remote\n";
		print DYN_YML "  ansible.builtin.copy:\n";
		print DYN_YML "    src: \"{{playbook_dir}}/../scripts_for_remote/rollback_ifcfg_changes.sh\"\n";
		print DYN_YML "    dest: \"$remote_dir_for_absible_helper_l/rollback_ifcfg_changes.sh\"\n";
    		print DYN_YML "    mode: '0700'\n";
		print DYN_YML "\n";
		print DYN_YML "######################################################\n";
		print DYN_YML "\n";
		
		print DYN_YML "- name: run script 'rollback_ifcfg_changes.sh' as process\n";
		print DYN_YML "  ansible.builtin.raw: \"nohup sh -c '$remote_dir_for_absible_helper_l/rollback_ifcfg_changes.sh $tmp_var_l >/dev/null 2>&1' & sleep 3\"\n";
		print DYN_YML "\n";
		print DYN_YML "######################################################\n";
		print DYN_YML "\n";

	    }
	    ###task for config_temporary_apply_ifcfg

	    print DYN_YML "- name: restart network.service\n";
	    print DYN_YML "  ansible.builtin.systemd:\n";
	    print DYN_YML "    name: network.service\n";
	    print DYN_YML "    state: restarted\n";
	    print DYN_YML "\n";
	    print DYN_YML "######################################################\n";
	    print DYN_YML "\n";
	}
	
	###task for copy resolv.conf
	if ( exists(${$inv_hosts_dns_href_l}{$hkey0_l}) ) { #use special resolv.conf for inv_host
	    print DYN_YML "- name: copy/upd resolv.conf\n";
	    print DYN_YML "  ansible.builtin.copy:\n";
	    print DYN_YML "    src: \"{{playbook_dir}}/dyn_resolv_conf/{{inventory_hostname}}_resolv\"\n";
	    print DYN_YML "    dest: \"/etc/resolv.conf\"\n";
    	    print DYN_YML "    owner: root\n";
    	    print DYN_YML "    group: root\n";
    	    print DYN_YML "    mode: '0600'\n";
    	    print DYN_YML "    seuser: system_u\n";
    	    print DYN_YML "    setype: net_conf_t\n";
    	    print DYN_YML "    serole: object_r\n";
    	    print DYN_YML "    selevel: s0\n";
    	    print DYN_YML "    backup: yes\n";
	}
	elsif ( ${$inv_hosts_dns_href_l}{'common'} ) { #use common resolv.conf
	    print DYN_YML "- name: copy/upd ifcfg-files\n";
	    print DYN_YML "  ansible.builtin.copy:\n";
	    print DYN_YML "    src: \"{{playbook_dir}}/dyn_resolv_conf/common_resolv\"\n";
	    print DYN_YML "    dest: \"/etc/resolv.conf\"\n";
    	    print DYN_YML "    owner: root\n";
    	    print DYN_YML "    group: root\n";
    	    print DYN_YML "    mode: '0600'\n";
    	    print DYN_YML "    seuser: system_u\n";
    	    print DYN_YML "    setype: net_conf_t\n";
    	    print DYN_YML "    serole: object_r\n";
    	    print DYN_YML "    selevel: s0\n";
    	    print DYN_YML "    backup: yes\n";
	}
	print DYN_YML "\n";
	print DYN_YML "######################################################\n";
	print DYN_YML "\n";
	###task for copy resolv.conf
	
	###for cancel operation of rollback ifcfg changes if run 'apply_immediately_ifcfg.sh' with GEN_DYN_IFCFG_RUN='yes'
	if ( $gen_playbooks_next_with_rollback_l==0 ) {
	    print DYN_YML "- name: cancel rollback operation (rollback_ifcfg_changes.sh) if need\n";
	    print DYN_YML "  ansible.builtin.command: \"pkill -9 -f rollback_ifcfg_changes\"\n";
	    print DYN_YML "  ignore_errors: yes\n";
	    print DYN_YML "\n";
	    print DYN_YML "######################################################\n";
	    print DYN_YML "\n";
	}
	###for cancel operation of rollback ifcfg changes if run 'apply_immediately_ifcfg.sh' with GEN_DYN_IFCFG_RUN='yes'
	
	close(DYN_YML);
	$tmp_file0_l=undef;
    }
    ($hkey0_l,$hval0_l)=(undef,undef);
    ($hkey1_l,$hval1_l)=(undef,undef);
    $tmp_file0_l=undef;
    
    return $return_str_l;
}
##

###INCLUDED to conf_type_sub_refs_g
##common (novlan)
sub just_interface_gen_ifcfg {
    my ($tmplt_dir_l,$target_dyn_ifcfg_dir_l,$prms_href_l)=@_;
    ###if STATIC. TMPLT = playbooks/ifcfg_tmplt/just_interface/ifcfg-eth-static
    #TMPLT_VALUES_FOR_REPLACE:_defroute_, _interface_name_, _hwaddr_, _ipaddr_, _netmask_, _gw_, _conf_id_
    ###
    
    ###if DHCP. TMPLT = playbooks/ifcfg_tmplt/just_interface/ifcfg-eth-dhcp
    #TMPLT_VALUES_FOR_REPLACE:_defroute_, _interface_name_, _hwaddr_, _conf_id_
    ###
    
    ###
    #HREF->{'main'}{'_inv_host_'}=inv_host;
    #HREF->{'main'}{'_conf_id_'}=conf_id;
    #HREF->{'main'}{'_vlan_id_'}=vlan_id;
    #HREF->{'main'}{'_bond_name_'}=bond_name;
    #HREF->{'main'}{'_bridge_name_'}=bridge_name;
    #HREF->{'main'}{'_defroute_'}=defroute;
    #HREF->{'main'}{'_ipaddr_'}=ipaddr/dhcp;
    #HREF->{'main'}{'_gw_'}=gw/dhcp;
    #HREF->{'main'}{'_netmask_'}=gw/dhcp;
    #HREF->{'main'}{'_bond_opts_'}=bond_opts_string_for_ifcfg;
    #HREF->{'int_list'}=[array of interfaces];
    #HREF->{'hwaddr_list'}=[array of hwaddr];
    ###
    
    my @int_list_l=@{${$prms_href_l}{'int_list'}};
    my @hwaddr_list_l=@{${$prms_href_l}{'hwaddr_list'}};

    ###vars
    my $arr_i0_l=0;
    my $ifcfg_file_path_l=undef;
    ###vars
        
    for ( $arr_i0_l=0; $arr_i0_l<=$#int_list_l; $arr_i0_l++ ) {
	$ifcfg_file_path_l=$target_dyn_ifcfg_dir_l.'/ifcfg-'.$int_list_l[$arr_i0_l];
	if ( ${$prms_href_l}{'main'}{'_ipaddr_'} eq 'dhcp' ) {
	    system("cp ".$tmplt_dir_l.'/ifcfg-eth-dhcp'.' '.$ifcfg_file_path_l);
	    
	    &replace_values_in_file($ifcfg_file_path_l,'eth-dhcp',$int_list_l[$arr_i0_l],$hwaddr_list_l[$arr_i0_l],$prms_href_l);
	    #$file_path_l,$file_type_l,$int_name_l,$hwaddr_l,$prms_href_l
	}
	else {
	    system("cp ".$tmplt_dir_l.'/ifcfg-eth-static'.' '.$ifcfg_file_path_l);

	    &replace_values_in_file($ifcfg_file_path_l,'eth-static',$int_list_l[$arr_i0_l],$hwaddr_list_l[$arr_i0_l],$prms_href_l);
	    #$file_path_l,$file_type_l,$int_name_l,$hwaddr_l,$prms_href_l
	}
    }

    ###some other specific operations if need
}

sub virt_bridge_gen_ifcfg {
    my ($tmplt_dir_l,$target_dyn_ifcfg_dir_l,$prms_href_l)=@_;
    ###if STATIC. TMPLT = playbooks/ifcfg_tmplt/virt_bridge/ifcfg-bridge-static
    #TMPLT_VALUES_FOR_REPLACE:_bridge_name_, _ipaddr_, _netmask_, _conf_id_
    ###

    ###
    #HREF->{'main'}{'_inv_host_'}=inv_host;
    #HREF->{'main'}{'_conf_id_'}=conf_id;
    #HREF->{'main'}{'_vlan_id_'}=vlan_id;
    #HREF->{'main'}{'_bond_name_'}=bond_name;
    #HREF->{'main'}{'_bridge_name_'}=bridge_name;
    #HREF->{'main'}{'_defroute_'}=defroute;
    #HREF->{'main'}{'_ipaddr_'}=ipaddr/dhcp;
    #HREF->{'main'}{'_gw_'}=gw/dhcp;
    #HREF->{'main'}{'_netmask_'}=gw/dhcp;
    #HREF->{'main'}{'_bond_opts_'}=bond_opts_string_for_ifcfg;
    #HREF->{'int_list'}=[array of interfaces];
    #HREF->{'hwaddr_list'}=[array of hwaddr];
    ###
    my @int_list_l=@{${$prms_href_l}{'int_list'}};
    my @hwaddr_list_l=@{${$prms_href_l}{'hwaddr_list'}};
    
    ###vars
    my $ifcfg_file_path_l=$target_dyn_ifcfg_dir_l.'/ifcfg-'.${$prms_href_l}{'main'}{'_bridge_name_'};
    ###vars
    
    system("cp ".$tmplt_dir_l.'/ifcfg-bridge-static'.' '.$ifcfg_file_path_l);
    
    &replace_values_in_file($ifcfg_file_path_l,'virt-bridge','no','no',$prms_href_l);
    #$file_path_l,$file_type_l,$int_name_l,$hwaddr_l,$prms_href_l

    ###some other specific operations if need
}

sub just_bridge_gen_ifcfg {
    my ($tmplt_dir_l,$target_dyn_ifcfg_dir_l,$prms_href_l)=@_;
    #interface -> bridge
    
    ###ETH for BRIDGE. tmplt = playbooks/ifcfg_tmplt/just_bridge/ifcfg-eth
    #TMPLT_VALUES_FOR_REPLACE:_interface_name_, _bridge_name_, _hwaddr_, _conf_id_
    ###
    
    ###if STATIC. TMPLT = playbooks/ifcfg_tmplt/just_bridge/ifcfg-bridge-static
    #TMPLT_VALUES_FOR_REPLACE:_defroute_, _bridge_name_, _ipaddr_, _gw_, _netmask_, _conf_id_
    ###

    ###if DHCP. TMPLT = playbooks/ifcfg_tmplt/just_bridge/ifcfg-bridge-dhcp
    #TMPLT_VALUES_FOR_REPLACE:_defroute_, _bridge_name_, _conf_id_
    ###

    ###
    #HREF->{'main'}{'_inv_host_'}=inv_host;
    #HREF->{'main'}{'_conf_id_'}=conf_id;
    #HREF->{'main'}{'_vlan_id_'}=vlan_id;
    #HREF->{'main'}{'_bond_name_'}=bond_name;
    #HREF->{'main'}{'_bridge_name_'}=bridge_name;
    #HREF->{'main'}{'_defroute_'}=defroute;
    #HREF->{'main'}{'_ipaddr_'}=ipaddr/dhcp;
    #HREF->{'main'}{'_gw_'}=gw/dhcp;
    #HREF->{'main'}{'_netmask_'}=gw/dhcp;
    #HREF->{'main'}{'_bond_opts_'}=bond_opts_string_for_ifcfg;
    #HREF->{'int_list'}=[array of interfaces];
    #HREF->{'hwaddr_list'}=[array of hwaddr];
    ###
    my @int_list_l=@{${$prms_href_l}{'int_list'}};
    my @hwaddr_list_l=@{${$prms_href_l}{'hwaddr_list'}};

    ###vars
    my $arr_i0_l=0;
    my $ifcfg_file_path_l=undef;
    ###vars

    for ( $arr_i0_l=0; $arr_i0_l<=$#int_list_l; $arr_i0_l++ ) {
	$ifcfg_file_path_l=$target_dyn_ifcfg_dir_l.'/ifcfg-'.$int_list_l[$arr_i0_l];
	system("cp ".$tmplt_dir_l.'/ifcfg-eth'.' '.$ifcfg_file_path_l);
	
	&replace_values_in_file($ifcfg_file_path_l,'eth-for-bridge',$int_list_l[$arr_i0_l],$hwaddr_list_l[$arr_i0_l],$prms_href_l);
	#$file_path_l,$file_type_l,$int_name_l,$hwaddr_l,$prms_href_l
    }
    $ifcfg_file_path_l=undef;

    $ifcfg_file_path_l=$target_dyn_ifcfg_dir_l.'/ifcfg-'.${$prms_href_l}{'main'}{'_bridge_name_'};
    if ( ${$prms_href_l}{'main'}{'_ipaddr_'} eq 'dhcp' ) {
	system("cp ".$tmplt_dir_l.'/ifcfg-bridge-dhcp'.' '.$ifcfg_file_path_l);
	
	&replace_values_in_file($ifcfg_file_path_l,'bridge-dhcp','no','no',$prms_href_l);
	#$file_path_l,$file_type_l,$int_name_l,$hwaddr_l,$prms_href_l
    }
    else {
	system("cp ".$tmplt_dir_l.'/ifcfg-bridge-static'.' '.$ifcfg_file_path_l);
	
	&replace_values_in_file($ifcfg_file_path_l,'bridge-static','no','no',$prms_href_l);
	#$file_path_l,$file_type_l,$int_name_l,$hwaddr_l,$prms_href_l
    }

    ###some other specific operations if need
}

sub just_bond_gen_ifcfg {
    my ($tmplt_dir_l,$target_dyn_ifcfg_dir_l,$prms_href_l)=@_;
    #interface1+interface2 -> bond
    
    ###ETH for bond. tmplt = playbooks/ifcfg_tmplt/just_bond/ifcfg-eth
    #TMPLT_VALUES_FOR_REPLACE:_interface_name_, _bond_name_, _hwaddr_, _conf_id_
    ###
    
    ###if STATIC. TMPLT = playbooks/ifcfg_tmplt/just_bond/ifcfg-bond-static
    #TMPLT_VALUES_FOR_REPLACE:_defroute_, _bond_name_, _bond_opts_, _ipaddr_, _gw_, _netmask_, _conf_id_
    ###

    ###if DHCP. TMPLT = playbooks/ifcfg_tmplt/just_bond/ifcfg-bond-dhcp
    #TMPLT_VALUES_FOR_REPLACE:_defroute_, _bond_name_, _bond_opts_, _conf_id_
    ###

    ###
    #HREF->{'main'}{'_inv_host_'}=inv_host;
    #HREF->{'main'}{'_conf_id_'}=conf_id;
    #HREF->{'main'}{'_vlan_id_'}=vlan_id;
    #HREF->{'main'}{'_bond_name_'}=bond_name;
    #HREF->{'main'}{'_bridge_name_'}=bridge_name;
    #HREF->{'main'}{'_defroute_'}=defroute;
    #HREF->{'main'}{'_ipaddr_'}=ipaddr/dhcp;
    #HREF->{'main'}{'_gw_'}=gw/dhcp;
    #HREF->{'main'}{'_netmask_'}=gw/dhcp;
    #HREF->{'main'}{'_bond_opts_'}=bond_opts_string_for_ifcfg;
    #HREF->{'int_list'}=[array of interfaces];
    #HREF->{'hwaddr_list'}=[array of hwaddr];
    ###
    my @int_list_l=@{${$prms_href_l}{'int_list'}};
    my @hwaddr_list_l=@{${$prms_href_l}{'hwaddr_list'}};

    ###vars
    my $arr_i0_l=0;
    my $ifcfg_file_path_l=undef;
    ###vars

    for ( $arr_i0_l=0; $arr_i0_l<=$#int_list_l; $arr_i0_l++ ) {
	$ifcfg_file_path_l=$target_dyn_ifcfg_dir_l.'/ifcfg-'.$int_list_l[$arr_i0_l];
	system("cp ".$tmplt_dir_l.'/ifcfg-eth'.' '.$ifcfg_file_path_l);
	
	&replace_values_in_file($ifcfg_file_path_l,'eth-for-bond',$int_list_l[$arr_i0_l],$hwaddr_list_l[$arr_i0_l],$prms_href_l);
	#$file_path_l,$file_type_l,$int_name_l,$hwaddr_l,$prms_href_l
    }
    $ifcfg_file_path_l=undef;

    $ifcfg_file_path_l=$target_dyn_ifcfg_dir_l.'/ifcfg-'.${$prms_href_l}{'main'}{'_bond_name_'};
    if ( ${$prms_href_l}{'main'}{'_ipaddr_'} eq 'dhcp' ) {
	system("cp ".$tmplt_dir_l.'/ifcfg-bond-dhcp'.' '.$ifcfg_file_path_l);
	
	&replace_values_in_file($ifcfg_file_path_l,'bond-dhcp','no','no',$prms_href_l);
	#$file_path_l,$file_type_l,$int_name_l,$hwaddr_l,$prms_href_l
    }
    else {
	system("cp ".$tmplt_dir_l.'/ifcfg-bond-static'.' '.$ifcfg_file_path_l);
	
	&replace_values_in_file($ifcfg_file_path_l,'bond-static','no','no',$prms_href_l);
	#$file_path_l,$file_type_l,$int_name_l,$hwaddr_l,$prms_href_l
    }

    ###some other specific operations if need
}

sub bond_bridge_gen_ifcfg {
    my ($tmplt_dir_l,$target_dyn_ifcfg_dir_l,$prms_href_l)=@_;
    #interface1+interface2 -> bond -> bridge
    
    ###ETH for bond. tmplt = playbooks/ifcfg_tmplt/bond-bridge/ifcfg-eth
    #TMPLT_VALUES_FOR_REPLACE:_interface_name_, _bond_name_, _hwaddr_, _conf_id_
    ###
    
    ###BOND for bridge. TMPLT = playbooks/ifcfg_tmplt/bond-bridge/ifcfg-bond
    #TMPLT_VALUES_FOR_REPLACE:_bond_name_, _bond_opts_, _bridge_name_, _conf_id_
    ###

    ###if STATIC. TMPLT = playbooks/ifcfg_tmplt/bond-bridge/ifcfg-bridge-static
    #TMPLT_VALUES_FOR_REPLACE:_defroute_, _bridge_name_, _ipaddr_, _gw_, _netmask_, _conf_id_
    ###

    ###if DHCP. TMPLT = playbooks/ifcfg_tmplt/bond-bridge/ifcfg-bridge-dhcp
    #TMPLT_VALUES_FOR_REPLACE:_defroute_, _bridge_name_, _conf_id_
    ###

    ###
    #HREF->{'main'}{'_inv_host_'}=inv_host;
    #HREF->{'main'}{'_conf_id_'}=conf_id;
    #HREF->{'main'}{'_vlan_id_'}=vlan_id;
    #HREF->{'main'}{'_bond_name_'}=bond_name;
    #HREF->{'main'}{'_bridge_name_'}=bridge_name;
    #HREF->{'main'}{'_defroute_'}=defroute;
    #HREF->{'main'}{'_ipaddr_'}=ipaddr/dhcp;
    #HREF->{'main'}{'_gw_'}=gw/dhcp;
    #HREF->{'main'}{'_netmask_'}=gw/dhcp;
    #HREF->{'main'}{'_bond_opts_'}=bond_opts_string_for_ifcfg;
    #HREF->{'int_list'}=[array of interfaces];
    #HREF->{'hwaddr_list'}=[array of hwaddr];
    ###
    my @int_list_l=@{${$prms_href_l}{'int_list'}};
    my @hwaddr_list_l=@{${$prms_href_l}{'hwaddr_list'}};

    ###vars
    my $arr_i0_l=0;
    my $ifcfg_file_path_l=undef;
    ###vars

    for ( $arr_i0_l=0; $arr_i0_l<=$#int_list_l; $arr_i0_l++ ) {
	$ifcfg_file_path_l=$target_dyn_ifcfg_dir_l.'/ifcfg-'.$int_list_l[$arr_i0_l];
	system("cp ".$tmplt_dir_l.'/ifcfg-eth'.' '.$ifcfg_file_path_l);
	
	&replace_values_in_file($ifcfg_file_path_l,'eth-for-bond',$int_list_l[$arr_i0_l],$hwaddr_list_l[$arr_i0_l],$prms_href_l);
	#$file_path_l,$file_type_l,$int_name_l,$hwaddr_l,$prms_href_l
    }
    $ifcfg_file_path_l=undef;

    $ifcfg_file_path_l=$target_dyn_ifcfg_dir_l.'/ifcfg-'.${$prms_href_l}{'main'}{'_bond_name_'};
    system("cp ".$tmplt_dir_l.'/ifcfg-bond'.' '.$ifcfg_file_path_l);
	
    &replace_values_in_file($ifcfg_file_path_l,'bond-for-bridge','no','no',$prms_href_l);
    #$file_path_l,$file_type_l,$int_name_l,$hwaddr_l,$prms_href_l
    $ifcfg_file_path_l=undef;

    $ifcfg_file_path_l=$target_dyn_ifcfg_dir_l.'/ifcfg-'.${$prms_href_l}{'main'}{'_bridge_name_'};
    if ( ${$prms_href_l}{'main'}{'_ipaddr_'} eq 'dhcp' ) {
	system("cp ".$tmplt_dir_l.'/ifcfg-bridge-dhcp'.' '.$ifcfg_file_path_l);
	
	&replace_values_in_file($ifcfg_file_path_l,'bridge-dhcp','no','no',$prms_href_l);
	#$file_path_l,$file_type_l,$int_name_l,$hwaddr_l,$prms_href_l
    }
    else {
	system("cp ".$tmplt_dir_l.'/ifcfg-bridge-static'.' '.$ifcfg_file_path_l);
	
	&replace_values_in_file($ifcfg_file_path_l,'bridge-static','no','no',$prms_href_l);
	#$file_path_l,$file_type_l,$int_name_l,$hwaddr_l,$prms_href_l
    }

    ###some other specific operations if need
}
#

##vlan
sub interface_vlan_gen_ifcfg {
    my ($tmplt_dir_l,$target_dyn_ifcfg_dir_l,$prms_href_l)=@_;
    ###if STATIC. TMPLT = playbooks/ifcfg_tmplt/interface-vlan/ifcfg-eth-static
    #TMPLT_VALUES_FOR_REPLACE:_defroute_, _interface_name_, _hwaddr_, _ipaddr_, _netmask_, _gw_, _conf_id_
    ###
    
    ###if DHCP. TMPLT = playbooks/ifcfg_tmplt/interface-vlan/ifcfg-eth-dhcp
    #TMPLT_VALUES_FOR_REPLACE:_defroute_, _interface_name_, _hwaddr_, _conf_id_
    ###

    ###
    #HREF->{'main'}{'_inv_host_'}=inv_host;
    #HREF->{'main'}{'_conf_id_'}=conf_id;
    #HREF->{'main'}{'_vlan_id_'}=vlan_id;
    #HREF->{'main'}{'_bond_name_'}=bond_name;
    #HREF->{'main'}{'_bridge_name_'}=bridge_name;
    #HREF->{'main'}{'_defroute_'}=defroute;
    #HREF->{'main'}{'_ipaddr_'}=ipaddr/dhcp;
    #HREF->{'main'}{'_gw_'}=gw/dhcp;
    #HREF->{'main'}{'_netmask_'}=gw/dhcp;
    #HREF->{'main'}{'_bond_opts_'}=bond_opts_string_for_ifcfg;
    #HREF->{'int_list'}=[array of interfaces];
    #HREF->{'hwaddr_list'}=[array of hwaddr];
    ###
    my @int_list_l=@{${$prms_href_l}{'int_list'}};
    my @hwaddr_list_l=@{${$prms_href_l}{'hwaddr_list'}};

    ###vars
    my $arr_i0_l=0;
    my $ifcfg_file_path_l=undef;
    ###vars
        
    for ( $arr_i0_l=0; $arr_i0_l<=$#int_list_l; $arr_i0_l++ ) {
	$ifcfg_file_path_l=$target_dyn_ifcfg_dir_l.'/ifcfg-'.$int_list_l[$arr_i0_l];
	if ( ${$prms_href_l}{'main'}{'_ipaddr_'} eq 'dhcp' ) {
	    system("cp ".$tmplt_dir_l.'/ifcfg-eth-dhcp'.' '.$ifcfg_file_path_l);
	    
	    &replace_values_in_file($ifcfg_file_path_l,'eth-dhcp',$int_list_l[$arr_i0_l],$hwaddr_list_l[$arr_i0_l],$prms_href_l);
	    #$file_path_l,$file_type_l,$int_name_l,$hwaddr_l,$prms_href_l
	}
	else {
	    system("cp ".$tmplt_dir_l.'/ifcfg-eth-static'.' '.$ifcfg_file_path_l);

	    &replace_values_in_file($ifcfg_file_path_l,'eth-static',$int_list_l[$arr_i0_l],$hwaddr_list_l[$arr_i0_l],$prms_href_l);
	    #$file_path_l,$file_type_l,$int_name_l,$hwaddr_l,$prms_href_l
	}
    }

    ###some other specific operations if need
}

sub bridge_vlan_gen_ifcfg {
    my ($tmplt_dir_l,$target_dyn_ifcfg_dir_l,$prms_href_l)=@_;
    #interface-vlan -> bridge
    
    ###ETH for BRIDGE-vlan. tmplt = playbooks/ifcfg_tmplt/bridge-vlan/ifcfg-eth
    #TMPLT_VALUES_FOR_REPLACE:_interface_name_, _bridge_name_, _hwaddr_, _conf_id_
    ###
    
    ###if STATIC. TMPLT = playbooks/ifcfg_tmplt/bridge-vlan/ifcfg-bridge-static
    #TMPLT_VALUES_FOR_REPLACE:_defroute_, _bridge_name_, _ipaddr_, _gw_, _netmask_, _conf_id_
    ###

    ###if DHCP. TMPLT = playbooks/ifcfg_tmplt/bridge-vlan/ifcfg-bridge-dhcp
    #TMPLT_VALUES_FOR_REPLACE:_defroute_, _bridge_name_, _conf_id_
    ###

    ###
    #HREF->{'main'}{'_inv_host_'}=inv_host;
    #HREF->{'main'}{'_conf_id_'}=conf_id;
    #HREF->{'main'}{'_vlan_id_'}=vlan_id;
    #HREF->{'main'}{'_bond_name_'}=bond_name;
    #HREF->{'main'}{'_bridge_name_'}=bridge_name;
    #HREF->{'main'}{'_defroute_'}=defroute;
    #HREF->{'main'}{'_ipaddr_'}=ipaddr/dhcp;
    #HREF->{'main'}{'_gw_'}=gw/dhcp;
    #HREF->{'main'}{'_netmask_'}=gw/dhcp;
    #HREF->{'main'}{'_bond_opts_'}=bond_opts_string_for_ifcfg;
    #HREF->{'int_list'}=[array of interfaces];
    #HREF->{'hwaddr_list'}=[array of hwaddr];
    ###
    my @int_list_l=@{${$prms_href_l}{'int_list'}};
    my @hwaddr_list_l=@{${$prms_href_l}{'hwaddr_list'}};

    ###vars
    my $arr_i0_l=0;
    my $ifcfg_file_path_l=undef;
    ###vars

    for ( $arr_i0_l=0; $arr_i0_l<=$#int_list_l; $arr_i0_l++ ) {
	$ifcfg_file_path_l=$target_dyn_ifcfg_dir_l.'/ifcfg-'.$int_list_l[$arr_i0_l];
	system("cp ".$tmplt_dir_l.'/ifcfg-eth'.' '.$ifcfg_file_path_l);
	
	&replace_values_in_file($ifcfg_file_path_l,'eth-for-bridge',$int_list_l[$arr_i0_l],$hwaddr_list_l[$arr_i0_l],$prms_href_l);
	#$file_path_l,$file_type_l,$int_name_l,$hwaddr_l,$prms_href_l
    }
    $ifcfg_file_path_l=undef;

    $ifcfg_file_path_l=$target_dyn_ifcfg_dir_l.'/ifcfg-'.${$prms_href_l}{'main'}{'_bridge_name_'};
    if ( ${$prms_href_l}{'main'}{'_ipaddr_'} eq 'dhcp' ) {
	system("cp ".$tmplt_dir_l.'/ifcfg-bridge-dhcp'.' '.$ifcfg_file_path_l);
	
	&replace_values_in_file($ifcfg_file_path_l,'bridge-dhcp','no','no',$prms_href_l);
	#$file_path_l,$file_type_l,$int_name_l,$hwaddr_l,$prms_href_l
    }
    else {
	system("cp ".$tmplt_dir_l.'/ifcfg-bridge-static'.' '.$ifcfg_file_path_l);
	
	&replace_values_in_file($ifcfg_file_path_l,'bridge-static','no','no',$prms_href_l);
	#$file_path_l,$file_type_l,$int_name_l,$hwaddr_l,$prms_href_l
    }

    ###some other specific operations if need
}

sub bond_vlan_gen_ifcfg {
    my ($tmplt_dir_l,$target_dyn_ifcfg_dir_l,$prms_href_l)=@_;
    #interface1+interface2 -> bond-vlan
    
    ###ETH for bond-vlan. tmplt = playbooks/ifcfg_tmplt/bond-vlan/ifcfg-eth
    #TMPLT_VALUES_FOR_REPLACE:_interface_name_, _bond_name_, _hwaddr_, _conf_id_
    ###
    
    ###if STATIC. TMPLT = playbooks/ifcfg_tmplt/bond-vlan/ifcfg-bond-static
    #TMPLT_VALUES_FOR_REPLACE:_defroute_, _bond_name_, _bond_opts_, _ipaddr_, _gw_, _netmask_, _conf_id_
    ###

    ###if DHCP. TMPLT = playbooks/ifcfg_tmplt/bond-vlan/ifcfg-bond-dhcp
    #TMPLT_VALUES_FOR_REPLACE:_defroute_, _bond_name_, _bond_opts_, _conf_id_
    ###

    ###
    #HREF->{'main'}{'_inv_host_'}=inv_host;
    #HREF->{'main'}{'_conf_id_'}=conf_id;
    #HREF->{'main'}{'_vlan_id_'}=vlan_id;
    #HREF->{'main'}{'_bond_name_'}=bond_name;
    #HREF->{'main'}{'_bridge_name_'}=bridge_name;
    #HREF->{'main'}{'_defroute_'}=defroute;
    #HREF->{'main'}{'_ipaddr_'}=ipaddr/dhcp;
    #HREF->{'main'}{'_gw_'}=gw/dhcp;
    #HREF->{'main'}{'_netmask_'}=gw/dhcp;
    #HREF->{'main'}{'_bond_opts_'}=bond_opts_string_for_ifcfg;
    #HREF->{'int_list'}=[array of interfaces];
    #HREF->{'hwaddr_list'}=[array of hwaddr];
    ###
    my @int_list_l=@{${$prms_href_l}{'int_list'}};
    my @hwaddr_list_l=@{${$prms_href_l}{'hwaddr_list'}};

    ###vars
    my $arr_i0_l=0;
    my $ifcfg_file_path_l=undef;
    ###vars

    for ( $arr_i0_l=0; $arr_i0_l<=$#int_list_l; $arr_i0_l++ ) {
	$ifcfg_file_path_l=$target_dyn_ifcfg_dir_l.'/ifcfg-'.$int_list_l[$arr_i0_l];
	system("cp ".$tmplt_dir_l.'/ifcfg-eth'.' '.$ifcfg_file_path_l);
	
	&replace_values_in_file($ifcfg_file_path_l,'eth-for-bond',$int_list_l[$arr_i0_l],$hwaddr_list_l[$arr_i0_l],$prms_href_l);
	#$file_path_l,$file_type_l,$int_name_l,$hwaddr_l,$prms_href_l
    }
    $ifcfg_file_path_l=undef;

    $ifcfg_file_path_l=$target_dyn_ifcfg_dir_l.'/ifcfg-'.${$prms_href_l}{'main'}{'_bond_name_'};
    if ( ${$prms_href_l}{'main'}{'_ipaddr_'} eq 'dhcp' ) {
	system("cp ".$tmplt_dir_l.'/ifcfg-bond-dhcp'.' '.$ifcfg_file_path_l);
	
	&replace_values_in_file($ifcfg_file_path_l,'bond-dhcp','no','no',$prms_href_l);
	#$file_path_l,$file_type_l,$int_name_l,$hwaddr_l,$prms_href_l
    }
    else {
	system("cp ".$tmplt_dir_l.'/ifcfg-bond-static'.' '.$ifcfg_file_path_l);
	
	&replace_values_in_file($ifcfg_file_path_l,'bond-static','no','no',$prms_href_l);
	#$file_path_l,$file_type_l,$int_name_l,$hwaddr_l,$prms_href_l
    }

    ###some other specific operations if need
}

sub bond_bridge_vlan_gen_ifcfg {
    my ($tmplt_dir_l,$target_dyn_ifcfg_dir_l,$prms_href_l)=@_;
    #interface1+interface2 -> bondbrvlan -> bond-bridge-vlan
    
    ###ETH for bond4bondbrvlan. tmplt = playbooks/ifcfg_tmplt/bond-bridge-vlan/ifcfg-eth
    #TMPLT_VALUES_FOR_REPLACE:_interface_name_, _bond_name_, _hwaddr_, _conf_id_
    ###
    
    ###BOND for bondbrvlan. TMPLT = playbooks/ifcfg_tmplt/bond-bridge-vlan/ifcfg-bond
    #TMPLT_VALUES_FOR_REPLACE:_bond_name_, _bond_opts_, _bridge_name_, _conf_id_
    ###

    ###if STATIC. TMPLT = playbooks/ifcfg_tmplt/bond-bridge-vlan/ifcfg-bridge-static
    #TMPLT_VALUES_FOR_REPLACE:_defroute_, _bridge_name_, _ipaddr_, _gw_, _netmask_, _conf_id_
    ###

    ###if DHCP. TMPLT = playbooks/ifcfg_tmplt/bond-bridge-vlan/ifcfg-bridge-dhcp
    #TMPLT_VALUES_FOR_REPLACE:_defroute_, _bridge_name_, _conf_id_
    ###

    ###
    #HREF->{'main'}{'_inv_host_'}=inv_host;
    #HREF->{'main'}{'_conf_id_'}=conf_id;
    #HREF->{'main'}{'_vlan_id_'}=vlan_id;
    #HREF->{'main'}{'_bond_name_'}=bond_name;
    #HREF->{'main'}{'_bridge_name_'}=bridge_name;
    #HREF->{'main'}{'_defroute_'}=defroute;
    #HREF->{'main'}{'_ipaddr_'}=ipaddr/dhcp;
    #HREF->{'main'}{'_gw_'}=gw/dhcp;
    #HREF->{'main'}{'_netmask_'}=gw/dhcp;
    #HREF->{'main'}{'_bond_opts_'}=bond_opts_string_for_ifcfg;
    #HREF->{'int_list'}=[array of interfaces];
    #HREF->{'hwaddr_list'}=[array of hwaddr];
    ###
    my @int_list_l=@{${$prms_href_l}{'int_list'}};
    my @hwaddr_list_l=@{${$prms_href_l}{'hwaddr_list'}};

    ###vars
    my $arr_i0_l=0;
    my $ifcfg_file_path_l=undef;
    ###vars

    for ( $arr_i0_l=0; $arr_i0_l<=$#int_list_l; $arr_i0_l++ ) {
	$ifcfg_file_path_l=$target_dyn_ifcfg_dir_l.'/ifcfg-'.$int_list_l[$arr_i0_l];
	system("cp ".$tmplt_dir_l.'/ifcfg-eth'.' '.$ifcfg_file_path_l);
	
	&replace_values_in_file($ifcfg_file_path_l,'eth-for-bond',$int_list_l[$arr_i0_l],$hwaddr_list_l[$arr_i0_l],$prms_href_l);
	#$file_path_l,$file_type_l,$int_name_l,$hwaddr_l,$prms_href_l
    }
    $ifcfg_file_path_l=undef;

    $ifcfg_file_path_l=$target_dyn_ifcfg_dir_l.'/ifcfg-'.${$prms_href_l}{'main'}{'_bond_name_'};
    system("cp ".$tmplt_dir_l.'/ifcfg-bond'.' '.$ifcfg_file_path_l);
	
    &replace_values_in_file($ifcfg_file_path_l,'bond-for-bridge','no','no',$prms_href_l);
    #$file_path_l,$file_type_l,$int_name_l,$hwaddr_l,$prms_href_l
    $ifcfg_file_path_l=undef;

    $ifcfg_file_path_l=$target_dyn_ifcfg_dir_l.'/ifcfg-'.${$prms_href_l}{'main'}{'_bridge_name_'};
    if ( ${$prms_href_l}{'main'}{'_ipaddr_'} eq 'dhcp' ) {
	system("cp ".$tmplt_dir_l.'/ifcfg-bridge-dhcp'.' '.$ifcfg_file_path_l);
	
	&replace_values_in_file($ifcfg_file_path_l,'bridge-dhcp','no','no',$prms_href_l);
	#$file_path_l,$file_type_l,$int_name_l,$hwaddr_l,$prms_href_l
    }
    else {
	system("cp ".$tmplt_dir_l.'/ifcfg-bridge-static'.' '.$ifcfg_file_path_l);
	
	&replace_values_in_file($ifcfg_file_path_l,'bridge-static','no','no',$prms_href_l);
	#$file_path_l,$file_type_l,$int_name_l,$hwaddr_l,$prms_href_l
    }

    ###some other specific operations if need
}
##INCLUDED to conf_type_sub_refs_g

##other
sub ifcfg_diff_with_zone_param_save {
    #FOR REPLACE THIS=`diff $dyn_ifcfg_common_dir_g/$hkey0_g/fin/$hkey1_g $ifcfg_backup_from_remote_dir_g/$hkey0_g/$hkey1_g | wc -l`.
    #Compare file and add "firewall ZONE=*" (from_remote) to generated ifcfg.
    my ($ifcfg_generated_file_l,$ifcfg_from_remote_file_l)=@_;
    my ($zone_substr_l,$exec_res_l)=(undef,undef);
    
    $zone_substr_l=`grep -i zone $ifcfg_from_remote_file_l`;
    
    if ( defined($zone_substr_l) && length($zone_substr_l)>0 ) {
	$zone_substr_l=~s/\n|\r|\n\r|\r\n//g;
	$exec_res_l=`echo $zone_substr_l >> $ifcfg_generated_file_l`;
	$exec_res_l=undef;
    }
    
    $exec_res_l=`diff $ifcfg_generated_file_l $ifcfg_from_remote_file_l | wc -l`;
    $exec_res_l=~s/\n|\r|\n\r|\r\n//g;
    $exec_res_l=int($exec_res_l);
    
    return $exec_res_l;
}

sub replace_values_in_file {
    my ($file_path_l,$file_type_l,$int_name_l,$hwaddr_l,$prms_href_l)=@_;
    ###if STATIC. 		virt_bridge/ifcfg-bridge-static:	_bridge_name_, _ipaddr_, _netmask_, _conf_id_
    
    ###if STATIC.		just_interface/ifcfg-eth-static:	_defroute_, _interface_name_, _hwaddr_, _ipaddr_, _netmask_, _gw_, _conf_id_
    ###if DHCP. 		just_interface/ifcfg-eth-dhcp:		_defroute_, _interface_name_, _hwaddr_, _conf_id_
    
    ###ETH for BRIDGE. 		just_bridge/ifcfg-eth:			_interface_name_, _bridge_name_, _hwaddr_, _conf_id_
    ###if STATIC. 		just_bridge/ifcfg-bridge-static:	_defroute_, _bridge_name_, _ipaddr_, _gw_, _netmask_, _conf_id_
    ###if DHCP. 		just_bridge/ifcfg-bridge-dhcp:		_defroute_, _bridge_name_, _conf_id_
    
    ###ETH for bond. 		just_bond/ifcfg-eth:			_interface_name_, _bond_name_, _hwaddr_, _conf_id_
    ###if STATIC. 		just_bond/ifcfg-bond-static:		_defroute_, _bond_name_, _bond_opts_, _ipaddr_, _gw_, _netmask_, _conf_id_
    ###if DHCP. 		just_bond/ifcfg-bond-dhcp:		_defroute_, _bond_name_, _bond_opts_, _conf_id_
    
    ###ETH for bond. 		bond-bridge/ifcfg-eth:			_interface_name_, _bond_name_, _hwaddr_, _conf_id_
    ###BOND for bridge. 	bond-bridge/ifcfg-bond:			_bond_name_, _bond_opts_, _bridge_name_, _conf_id_
    ###if STATIC. 		bond-bridge/ifcfg-bridge-static:	_defroute_, _bridge_name_, _ipaddr_, _gw_, _netmask_, _conf_id_
    ###if DHCP. 		bond-bridge/ifcfg-bridge-dhcp:		_defroute_, _bridge_name_, _conf_id_
    
    ###if STATIC. 		interface-vlan/ifcfg-eth-static:	_defroute_, _interface_name_, _hwaddr_, _ipaddr_, _netmask_, _gw_, _conf_id_
    ###if DHCP. 		interface-vlan/ifcfg-eth-dhcp:		_defroute_, _interface_name_, _hwaddr_, _conf_id_
    
    ###ETH for BRIDGE-vlan.	bridge-vlan/ifcfg-eth:			_interface_name_, _bridge_name_, _hwaddr_, _conf_id_
    ###if STATIC. 		bridge-vlan/ifcfg-bridge-static:	_defroute_, _bridge_name_, _ipaddr_, _gw_, _netmask_, _conf_id_
    ###if DHCP. 		bridge-vlan/ifcfg-bridge-dhcp:		_defroute_, _bridge_name_, _conf_id_
    
    ###ETH for bond-vlan. 	bond-vlan/ifcfg-eth:			_interface_name_, _bond_name_, _hwaddr_, _conf_id_
    ###if STATIC. 		bond-vlan/ifcfg-bond-static:		_defroute_, _bond_name_, _bond_opts_, _ipaddr_, _gw_, _netmask_, _conf_id_
    ###if DHCP. 		bond-vlan/ifcfg-bond-dhcp:		_defroute_, _bond_name_, _bond_opts_, _conf_id_
    
    ###ETH for bond4bondbrvlan. bond-bridge-vlan/ifcfg-eth:		_interface_name_, _bond_name_, _hwaddr_, _conf_id_
    ###BOND for bondbrvlan. 	bond-bridge-vlan/ifcfg-bond:		_bond_name_, _bond_opts_, _bridge_name_, _conf_id_
    ###if STATIC. 		bond-bridge-vlan/ifcfg-bridge-static:	_defroute_, _bridge_name_, _ipaddr_, _gw_, _netmask_, _conf_id_
    ###if DHCP. 		bond-bridge-vlan/ifcfg-bridge-dhcp:	_defroute_, _bridge_name_, _conf_id_
    
    my $arr_el0_l=undef;
    
    my %file_type_hash_l=(
	'virt-bridge'=>		['_bridge_name_','_ipaddr_','_netmask_','_conf_id_'],
	###
	#just_bond, bond-bridge, bond-vlan, bond-bridge-vlan
	'eth-for-bond'=>	['_bond_name_','_conf_id_'], 
	###
	#just_bridge, bridge-vlan
	'eth-for-bridge'=>	['_bridge_name_','_conf_id_'],
	###
	##just_interface, interface-vlan
	'eth-static'=>		['_defroute_','_ipaddr_','_netmask_','_gw_','_conf_id_'],
	'eth-dhcp'=>		['_defroute_','_conf_id_'],
	###
	#just_bridge, bridge-vlan, bond-bridge-vlan
	'bridge-static'=>	['_defroute_','_bridge_name_','_ipaddr_','_gw_','_netmask_','_conf_id_'],
	'bridge-dhcp'=>		['_defroute_','_bridge_name_','_conf_id_'],
	###
	#just_bond
	'bond-static'=>		['_defroute_','_bond_name_','_bond_opts_','_ipaddr_','_gw_','_netmask_','_conf_id_'],
	'bond-dhcp'=>		['_defroute_','_bond_name_','_bond_opts_','_conf_id_'],
	###
	#bond-bridge-vlan, bond-bridge
	'bond-for-bridge'=>	['_bond_name_','_bond_opts_','_bridge_name_','_conf_id_']
    );
    
    if ( $hwaddr_l ne 'no' ) { system("sed -i -e 's/_hwaddr_/$hwaddr_l/g' $file_path_l"); }
    
    #if ( ${$prms_href_l}{'main'}{'_vlan_id_'} )
    if ( $int_name_l ne 'no' ) { system("sed -i -e 's/_interface_name_/$int_name_l/g' $file_path_l"); }    
    foreach $arr_el0_l ( @{$file_type_hash_l{$file_type_l}} ) {
	system("sed -i -e 's/$arr_el0_l/${$prms_href_l}{'main'}{$arr_el0_l}/g' $file_path_l");
    }
}
##other
######SUBROUTINES


#With best regards
#Chursin Vladimir ( https://github.com/vladimir-chursin000 )
